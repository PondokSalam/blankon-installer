/* installer.c generated by valac 0.26.1, the Vala compiler
 * generated from installer.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <JavaScriptCore/JavaScript.h>
#include <sys/wait.h>
#include <gee.h>
#include <glib/gstdio.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <unistd.h>
#include <locale.h>
#include <config.h>
#include <webkit/webkit.h>
#include <gdk/gdk.h>


#define TYPE_LOG (log_get_type ())
#define LOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOG, Log))
#define LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOG, LogClass))
#define IS_LOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOG))
#define IS_LOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOG))
#define LOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOG, LogClass))

typedef struct _Log Log;
typedef struct _LogClass LogClass;
typedef struct _LogPrivate LogPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_INSTALLATION (installation_get_type ())
#define INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLATION, Installation))
#define INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLATION, InstallationClass))
#define IS_INSTALLATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLATION))
#define IS_INSTALLATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLATION))
#define INSTALLATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLATION, InstallationClass))

typedef struct _Installation Installation;
typedef struct _InstallationClass InstallationClass;
typedef struct _InstallationPrivate InstallationPrivate;

#define INSTALLATION_TYPE_STEP (installation_step_get_type ())

#define INSTALLATION_TYPE_STATE (installation_state_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))

#define TYPE_DEVICE (device_get_type ())
#define DEVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEVICE, Device))
#define DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEVICE, DeviceClass))
#define IS_DEVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEVICE))
#define IS_DEVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEVICE))
#define DEVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEVICE, DeviceClass))

typedef struct _Device Device;
typedef struct _DeviceClass DeviceClass;

#define DEVICE_TYPE_PARTITION (device_partition_get_type ())
#define DEVICE_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DEVICE_TYPE_PARTITION, DevicePartition))
#define DEVICE_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), DEVICE_TYPE_PARTITION, DevicePartitionClass))
#define DEVICE_IS_PARTITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DEVICE_TYPE_PARTITION))
#define DEVICE_IS_PARTITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), DEVICE_TYPE_PARTITION))
#define DEVICE_PARTITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), DEVICE_TYPE_PARTITION, DevicePartitionClass))

typedef struct _DevicePartition DevicePartition;
typedef struct _DevicePartitionClass DevicePartitionClass;

#define DEVICE_TYPE_PARTITION_TYPE (device_partition_type_get_type ())
#define _JSStringRelease0(var) ((var == NULL) ? NULL : (var = (JSStringRelease (var), NULL)))
#define _0(var) ((var == NULL) ? NULL : (var = ( (var), NULL)))
#define _JSClassRelease0(var) ((var == NULL) ? NULL : (var = (JSClassRelease (var), NULL)))

#define TYPE_INSTALLER (installer_get_type ())
#define INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INSTALLER, Installer))
#define INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INSTALLER, InstallerClass))
#define IS_INSTALLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INSTALLER))
#define IS_INSTALLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INSTALLER))
#define INSTALLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INSTALLER, InstallerClass))

typedef struct _Installer Installer;
typedef struct _InstallerClass InstallerClass;
typedef struct _InstallerPrivate InstallerPrivate;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _Log {
	GObject parent_instance;
	LogPrivate * priv;
};

struct _LogClass {
	GObjectClass parent_class;
};

struct _LogPrivate {
	GDataOutputStream* stream;
};

struct _Installation {
	GObject parent_instance;
	InstallationPrivate * priv;
};

struct _InstallationClass {
	GObjectClass parent_class;
};

typedef enum  {
	INSTALLATION_STEP_IDLE,
	INSTALLATION_STEP_PARTITION,
	INSTALLATION_STEP_FS,
	INSTALLATION_STEP_MOUNT,
	INSTALLATION_STEP_COPY,
	INSTALLATION_STEP_SETUP,
	INSTALLATION_STEP_GRUB,
	INSTALLATION_STEP_CLEANUP,
	INSTALLATION_STEP_DONE
} InstallationStep;

struct _InstallationPrivate {
	gint _partition;
	gint _device;
	gchar* _user_name;
	gchar* _password;
	gchar* _host_name;
	gchar* _full_name;
	gchar* _grub_device;
	gchar* _language;
	gchar* _region;
	gchar* _keyboard;
	gboolean _autologin;
	gint _state;
	gint _progress;
	gchar* _description;
	guint64 installation_size;
	gchar* partition_path;
	gchar* device_path;
	InstallationStep step;
	InstallationStep last_step;
	GIOChannel* io_err;
	GIOChannel* io_out;
};

typedef enum  {
	INSTALLATION_STATE_NOT_STARTED,
	INSTALLATION_STATE_ON_GOING,
	INSTALLATION_STATE_ERROR,
	INSTALLATION_STATE_DONE
} InstallationState;

typedef enum  {
	DEVICE_PARTITION_TYPE_NORMAL,
	DEVICE_PARTITION_TYPE_LOGICAL,
	DEVICE_PARTITION_TYPE_EXTENDED,
	DEVICE_PARTITION_TYPE_FREESPACE,
	DEVICE_PARTITION_TYPE_METADATA,
	DEVICE_PARTITION_TYPE_PROTECTED,
	DEVICE_PARTITION_TYPE_INVALID
} DevicePartitionType;

typedef enum  {
	DEVICE_ERROR_CANT_CREATE_PARTITION
} DeviceError;
#define DEVICE_ERROR device_error_quark ()
struct _Installer {
	WebKitWebView parent_instance;
	InstallerPrivate * priv;
};

struct _InstallerClass {
	WebKitWebViewClass parent_class;
};

struct _InstallerPrivate {
	const gchar* debug;
};

struct _Block1Data {
	int _ref_count_;
	Installer* self;
	WebKitWebView* webview;
};


static gpointer log_parent_class = NULL;
static Log* log__instance;
static Log* log__instance = NULL;
static gpointer installation_parent_class = NULL;
static gpointer installer_parent_class = NULL;

GType log_get_type (void) G_GNUC_CONST;
#define LOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LOG, LogPrivate))
enum  {
	LOG_DUMMY_PROPERTY
};
Log* log_new (void);
Log* log_construct (GType object_type);
void log_log_without_newline (Log* self, const gchar* string);
void log_log (Log* self, const gchar* string);
Log* log_instance (void);
static void log_finalize (GObject* obj);
GType installation_get_type (void) G_GNUC_CONST;
static GType installation_step_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define INSTALLATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLATION, InstallationPrivate))
enum  {
	INSTALLATION_DUMMY_PROPERTY,
	INSTALLATION_PARTITION,
	INSTALLATION_DEVICE,
	INSTALLATION_USER_NAME,
	INSTALLATION_PASSWORD,
	INSTALLATION_HOST_NAME,
	INSTALLATION_FULL_NAME,
	INSTALLATION_GRUB_DEVICE,
	INSTALLATION_LANGUAGE,
	INSTALLATION_REGION,
	INSTALLATION_KEYBOARD,
	INSTALLATION_AUTOLOGIN,
	INSTALLATION_STATE,
	INSTALLATION_PROGRESS,
	INSTALLATION_DESCRIPTION
};
GType installation_state_get_type (void) G_GNUC_CONST;
#define INSTALLATION_OneGig ((guint64) ((1024 * 1024) * 1024))
void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception);
Installation* installation_new_from_string (const gchar* uri);
Installation* installation_construct_from_string (GType object_type, const gchar* uri);
static void installation_set_progress (Installation* self, gint value);
void installation_set_state (Installation* self, gint value);
void installation_set_description (Installation* self, const gchar* value);
void installation_set_autologin (Installation* self, gboolean value);
void installation_set_device (Installation* self, gint value);
void installation_set_partition (Installation* self, gint value);
void installation_set_user_name (Installation* self, const gchar* value);
void installation_set_password (Installation* self, const gchar* value);
void installation_set_host_name (Installation* self, const gchar* value);
void installation_set_full_name (Installation* self, const gchar* value);
void installation_set_grub_device (Installation* self, const gchar* value);
void installation_set_language (Installation* self, const gchar* value);
void installation_set_region (Installation* self, const gchar* value);
void installation_set_keyboard (Installation* self, const gchar* value);
static void __lambda7_ (Installation* self);
static void installation_real_start (Installation* self);
static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self);
void installation_start (Installation* self);
static void installation_do_next_job (Installation* self);
static void installation_do_partition (Installation* self);
static void installation_do_fs (Installation* self);
static void installation_do_mount (Installation* self);
static void installation_do_copy (Installation* self);
static void installation_do_setup (Installation* self);
static void installation_do_grub (Installation* self);
static void installation_do_cleanup (Installation* self);
static void installation_do_done (Installation* self);
gint installation_get_state (Installation* self);
static void installation_child_watch (Installation* self, GPid pid, gint status);
static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
static gint installation_run (Installation* self, gchar** command, int command_length1);
GType device_get_type (void) G_GNUC_CONST;
GeeArrayList* parted_get_devices (gboolean from_cache);
gint installation_get_device (Installation* self);
GType device_partition_get_type (void) G_GNUC_CONST;
GeeArrayList* device_get_partitions (Device* self);
gint installation_get_partition (Installation* self);
gchar* device_get_path (Device* self);
GType device_partition_type_get_type (void) G_GNUC_CONST;
DevicePartitionType device_partition_get_ptype (DevicePartition* self);
Device* device_new_from_name (const gchar* s);
Device* device_construct_from_name (GType object_type, const gchar* s);
GeeArrayList* swap_collector_get_partitions (void);
guint64 device_partition_get_size (DevicePartition* self);
GQuark device_error_quark (void);
gint device_create_partition (Device* self, guint64 byte_start, guint64 byte_end, const gchar* fs, guint64 swap_size, GError** error);
guint64 device_partition_get_start (DevicePartition* self);
guint64 device_partition_get_end (DevicePartition* self);
gint device_partition_get_number (DevicePartition* self);
static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description);
const gchar* installation_get_user_name (Installation* self);
const gchar* installation_get_password (Installation* self);
void utils_write_simple_file (const gchar* path, const gchar* content);
gboolean installation_get_autologin (Installation* self);
const gchar* installation_get_full_name (Installation* self);
const gchar* installation_get_host_name (Installation* self);
void swap_collector_reset (void);
static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition);
static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix);
static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition);
static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self);
static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception);
static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception);
const gchar* installation_get_description (Installation* self);
gint installation_get_progress (Installation* self);
void installation_setup_js_class (void* context);
Installation* installation_new (void);
Installation* installation_construct (GType object_type);
const gchar* installation_get_grub_device (Installation* self);
const gchar* installation_get_language (Installation* self);
const gchar* installation_get_region (Installation* self);
const gchar* installation_get_keyboard (Installation* self);
static void installation_finalize (GObject* obj);
static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType installer_get_type (void) G_GNUC_CONST;
#define INSTALLER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INSTALLER, InstallerPrivate))
enum  {
	INSTALLER_DUMMY_PROPERTY
};
static gchar* installer_translate_uri (Installer* self, const gchar* old);
static gchar* installer_translate_install (Installer* self, const gchar* uri);
static gchar* installer_translate_theme (Installer* self, const gchar* old);
gchar* utils_get_icon_path (const gchar* name, gint size);
Installer* installer_new (void);
Installer* installer_construct (GType object_type);
static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView);
static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self);
static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response);
static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self);
static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context);
void utils_setup_js_class (void* context);
void parted_setup_js_class (void* context);
static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static gboolean __lambda4_ (Block1Data* _data1_);
static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self);
void installer_start (Installer* self);
static void installer_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const JSStaticFunction INSTALLATION_js_funcs[7] = {{"shutdown", _installation_js_shutdown_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"reboot", _installation_js_reboot_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"translate", _installation_js_translate_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setLocale", _installation_js_set_locale_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"setTimezone", _installation_js_set_timezone_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {"getLocaleList", _installation_js_get_locale_list_js_core_object_call_as_function_callback, kJSPropertyAttributeReadOnly}, {NULL, NULL, 0}};
static const JSClassDefinition INSTALLATION_js_class = {0, kJSClassAttributeNone, "Installation", NULL, NULL, INSTALLATION_js_funcs, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, _installation_js_constructor_js_core_object_call_as_constructor_callback, NULL, NULL};

Log* log_construct (GType object_type) {
	Log * self = NULL;
	GError * _inner_error_ = NULL;
	self = (Log*) g_object_new (object_type, NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_ = NULL;
		GFile* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		GFileOutputStream* _tmp4_ = NULL;
		GFile* _tmp5_ = NULL;
		GFileOutputStream* _tmp6_ = NULL;
		GDataOutputStream* _tmp7_ = NULL;
		_tmp0_ = g_file_new_for_path ("/var/log/blankon-installer.log");
		file = _tmp0_;
		_tmp1_ = file;
		_tmp2_ = g_file_query_exists (_tmp1_, NULL);
		if (_tmp2_) {
			GFile* _tmp3_ = NULL;
			_tmp3_ = file;
			g_file_delete (_tmp3_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
		}
		_tmp5_ = file;
		_tmp6_ = g_file_create (_tmp5_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp4_ = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp7_ = g_data_output_stream_new ((GOutputStream*) _tmp4_);
		_g_object_unref0 (self->priv->stream);
		self->priv->stream = _tmp7_;
		_g_object_unref0 (_tmp4_);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp8_ = NULL;
		GError* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "%s\n", _tmp10_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Log* log_new (void) {
	return log_construct (TYPE_LOG);
}


void log_log_without_newline (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


void log_log (Log* self, const gchar* string) {
	GDataOutputStream* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GDataOutputStream* _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (string != NULL);
	_tmp0_ = self->priv->stream;
	_tmp1_ = string;
	g_data_output_stream_put_string (_tmp0_, _tmp1_, NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp2_ = self->priv->stream;
	g_data_output_stream_put_string (_tmp2_, "\n", NULL, &_inner_error_);
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Log* log_instance (void) {
	Log* result = NULL;
	Log* _tmp0_ = NULL;
	Log* _tmp2_ = NULL;
	Log* _tmp3_ = NULL;
	_tmp0_ = log__instance;
	if (_tmp0_ == NULL) {
		Log* _tmp1_ = NULL;
		_tmp1_ = log_new ();
		_g_object_unref0 (log__instance);
		log__instance = _tmp1_;
	}
	_tmp2_ = log__instance;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	result = _tmp3_;
	return result;
}


static void log_class_init (LogClass * klass) {
	log_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LogPrivate));
	G_OBJECT_CLASS (klass)->finalize = log_finalize;
}


static void log_instance_init (Log * self) {
	self->priv = LOG_GET_PRIVATE (self);
}


static void log_finalize (GObject* obj) {
	Log * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOG, Log);
	_g_object_unref0 (self->priv->stream);
	G_OBJECT_CLASS (log_parent_class)->finalize (obj);
}


GType log_get_type (void) {
	static volatile gsize log_type_id__volatile = 0;
	if (g_once_init_enter (&log_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) log_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Log), 0, (GInstanceInitFunc) log_instance_init, NULL };
		GType log_type_id;
		log_type_id = g_type_register_static (G_TYPE_OBJECT, "Log", &g_define_type_info, 0);
		g_once_init_leave (&log_type_id__volatile, log_type_id);
	}
	return log_type_id__volatile;
}


GType installation_state_get_type (void) {
	static volatile gsize installation_state_type_id__volatile = 0;
	if (g_once_init_enter (&installation_state_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STATE_NOT_STARTED, "INSTALLATION_STATE_NOT_STARTED", "not-started"}, {INSTALLATION_STATE_ON_GOING, "INSTALLATION_STATE_ON_GOING", "on-going"}, {INSTALLATION_STATE_ERROR, "INSTALLATION_STATE_ERROR", "error"}, {INSTALLATION_STATE_DONE, "INSTALLATION_STATE_DONE", "done"}, {0, NULL, NULL}};
		GType installation_state_type_id;
		installation_state_type_id = g_enum_register_static ("InstallationState", values);
		g_once_init_leave (&installation_state_type_id__volatile, installation_state_type_id);
	}
	return installation_state_type_id__volatile;
}


static GType installation_step_get_type (void) {
	static volatile gsize installation_step_type_id__volatile = 0;
	if (g_once_init_enter (&installation_step_type_id__volatile)) {
		static const GEnumValue values[] = {{INSTALLATION_STEP_IDLE, "INSTALLATION_STEP_IDLE", "idle"}, {INSTALLATION_STEP_PARTITION, "INSTALLATION_STEP_PARTITION", "partition"}, {INSTALLATION_STEP_FS, "INSTALLATION_STEP_FS", "fs"}, {INSTALLATION_STEP_MOUNT, "INSTALLATION_STEP_MOUNT", "mount"}, {INSTALLATION_STEP_COPY, "INSTALLATION_STEP_COPY", "copy"}, {INSTALLATION_STEP_SETUP, "INSTALLATION_STEP_SETUP", "setup"}, {INSTALLATION_STEP_GRUB, "INSTALLATION_STEP_GRUB", "grub"}, {INSTALLATION_STEP_CLEANUP, "INSTALLATION_STEP_CLEANUP", "cleanup"}, {INSTALLATION_STEP_DONE, "INSTALLATION_STEP_DONE", "done"}, {0, NULL, NULL}};
		GType installation_step_type_id;
		installation_step_type_id = g_enum_register_static ("InstallationStep", values);
		g_once_init_leave (&installation_step_type_id__volatile, installation_step_type_id);
	}
	return installation_step_type_id__volatile;
}


static void* _installation_js_shutdown_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_shutdown (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_reboot_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_reboot (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_translate_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_translate (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_locale_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_locale (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_set_timezone_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_set_timezone (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_get_locale_list_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_locale_list (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_constructor_js_core_object_call_as_constructor_callback (void* ctx, void* constructor, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_constructor (ctx, constructor, arguments, arguments_length1, exception);
	return result;
}


static void __lambda7_ (Installation* self) {
	installation_real_start (self);
}


static void ___lambda7__installation_installation_started (Installation* _sender, gpointer self) {
	__lambda7_ ((Installation*) self);
}


static guint64 uint64_parse (const gchar* str) {
	guint64 result = 0ULL;
	const gchar* _tmp0_ = NULL;
	guint64 _tmp1_ = 0ULL;
	g_return_val_if_fail (str != NULL, 0ULL);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtoull (_tmp0_, NULL, (guint) 0);
	result = _tmp1_;
	return result;
}


Installation* installation_construct_from_string (GType object_type, const gchar* uri) {
	Installation * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	self = (Installation*) g_object_new (object_type, NULL);
	installation_set_progress (self, 0);
	installation_set_state (self, (gint) INSTALLATION_STATE_NOT_STARTED);
	installation_set_description (self, "");
	installation_set_autologin (self, FALSE);
	_tmp0_ = uri;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "&", 0);
	{
		gchar** param_collection = NULL;
		gint param_collection_length1 = 0;
		gint _param_collection_size_ = 0;
		gint param_it = 0;
		param_collection = _tmp2_;
		param_collection_length1 = _vala_array_length (_tmp1_);
		for (param_it = 0; param_it < _vala_array_length (_tmp1_); param_it = param_it + 1) {
			gchar* _tmp3_ = NULL;
			gchar* param = NULL;
			_tmp3_ = g_strdup (param_collection[param_it]);
			param = _tmp3_;
			{
				gchar** entry = NULL;
				const gchar* _tmp4_ = NULL;
				gchar** _tmp5_ = NULL;
				gchar** _tmp6_ = NULL;
				gint entry_length1 = 0;
				gint _entry_size_ = 0;
				gchar** _tmp7_ = NULL;
				gint _tmp7__length1 = 0;
				_tmp4_ = param;
				_tmp6_ = _tmp5_ = g_strsplit (_tmp4_, "=", 0);
				entry = _tmp6_;
				entry_length1 = _vala_array_length (_tmp5_);
				_entry_size_ = entry_length1;
				_tmp7_ = entry;
				_tmp7__length1 = entry_length1;
				if (_tmp7__length1 == 2) {
					gchar** _tmp8_ = NULL;
					gint _tmp8__length1 = 0;
					const gchar* _tmp9_ = NULL;
					const gchar* _tmp10_ = NULL;
					GQuark _tmp12_ = 0U;
					static GQuark _tmp11_label0 = 0;
					static GQuark _tmp11_label1 = 0;
					static GQuark _tmp11_label2 = 0;
					static GQuark _tmp11_label3 = 0;
					static GQuark _tmp11_label4 = 0;
					static GQuark _tmp11_label5 = 0;
					static GQuark _tmp11_label6 = 0;
					static GQuark _tmp11_label7 = 0;
					static GQuark _tmp11_label8 = 0;
					static GQuark _tmp11_label9 = 0;
					static GQuark _tmp11_label10 = 0;
					_tmp8_ = entry;
					_tmp8__length1 = entry_length1;
					_tmp9_ = _tmp8_[0];
					_tmp10_ = _tmp9_;
					_tmp12_ = (NULL == _tmp10_) ? 0 : g_quark_from_string (_tmp10_);
					if (_tmp12_ == ((0 != _tmp11_label0) ? _tmp11_label0 : (_tmp11_label0 = g_quark_from_static_string ("device")))) {
						switch (0) {
							default:
							{
								gchar** _tmp13_ = NULL;
								gint _tmp13__length1 = 0;
								const gchar* _tmp14_ = NULL;
								gint _tmp15_ = 0;
								_tmp13_ = entry;
								_tmp13__length1 = entry_length1;
								_tmp14_ = _tmp13_[1];
								_tmp15_ = atoi (_tmp14_);
								installation_set_device (self, _tmp15_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label1) ? _tmp11_label1 : (_tmp11_label1 = g_quark_from_static_string ("partition")))) {
						switch (0) {
							default:
							{
								gchar** _tmp16_ = NULL;
								gint _tmp16__length1 = 0;
								const gchar* _tmp17_ = NULL;
								gint _tmp18_ = 0;
								_tmp16_ = entry;
								_tmp16__length1 = entry_length1;
								_tmp17_ = _tmp16_[1];
								_tmp18_ = atoi (_tmp17_);
								installation_set_partition (self, _tmp18_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label2) ? _tmp11_label2 : (_tmp11_label2 = g_quark_from_static_string ("username")))) {
						switch (0) {
							default:
							{
								gchar** _tmp19_ = NULL;
								gint _tmp19__length1 = 0;
								const gchar* _tmp20_ = NULL;
								_tmp19_ = entry;
								_tmp19__length1 = entry_length1;
								_tmp20_ = _tmp19_[1];
								installation_set_user_name (self, _tmp20_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label3) ? _tmp11_label3 : (_tmp11_label3 = g_quark_from_static_string ("password")))) {
						switch (0) {
							default:
							{
								gchar** _tmp21_ = NULL;
								gint _tmp21__length1 = 0;
								const gchar* _tmp22_ = NULL;
								_tmp21_ = entry;
								_tmp21__length1 = entry_length1;
								_tmp22_ = _tmp21_[1];
								installation_set_password (self, _tmp22_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label4) ? _tmp11_label4 : (_tmp11_label4 = g_quark_from_static_string ("hostname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp23_ = NULL;
								gint _tmp23__length1 = 0;
								const gchar* _tmp24_ = NULL;
								_tmp23_ = entry;
								_tmp23__length1 = entry_length1;
								_tmp24_ = _tmp23_[1];
								installation_set_host_name (self, _tmp24_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label5) ? _tmp11_label5 : (_tmp11_label5 = g_quark_from_static_string ("fullname")))) {
						switch (0) {
							default:
							{
								gchar** _tmp25_ = NULL;
								gint _tmp25__length1 = 0;
								const gchar* _tmp26_ = NULL;
								_tmp25_ = entry;
								_tmp25__length1 = entry_length1;
								_tmp26_ = _tmp25_[1];
								installation_set_full_name (self, _tmp26_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label6) ? _tmp11_label6 : (_tmp11_label6 = g_quark_from_static_string ("grubdevice")))) {
						switch (0) {
							default:
							{
								gchar** _tmp27_ = NULL;
								gint _tmp27__length1 = 0;
								const gchar* _tmp28_ = NULL;
								_tmp27_ = entry;
								_tmp27__length1 = entry_length1;
								_tmp28_ = _tmp27_[1];
								installation_set_grub_device (self, _tmp28_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label7) ? _tmp11_label7 : (_tmp11_label7 = g_quark_from_static_string ("language")))) {
						switch (0) {
							default:
							{
								gchar** _tmp29_ = NULL;
								gint _tmp29__length1 = 0;
								const gchar* _tmp30_ = NULL;
								_tmp29_ = entry;
								_tmp29__length1 = entry_length1;
								_tmp30_ = _tmp29_[1];
								installation_set_language (self, _tmp30_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label8) ? _tmp11_label8 : (_tmp11_label8 = g_quark_from_static_string ("region")))) {
						switch (0) {
							default:
							{
								gchar** _tmp31_ = NULL;
								gint _tmp31__length1 = 0;
								const gchar* _tmp32_ = NULL;
								_tmp31_ = entry;
								_tmp31__length1 = entry_length1;
								_tmp32_ = _tmp31_[1];
								installation_set_region (self, _tmp32_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label9) ? _tmp11_label9 : (_tmp11_label9 = g_quark_from_static_string ("keyboard")))) {
						switch (0) {
							default:
							{
								gchar** _tmp33_ = NULL;
								gint _tmp33__length1 = 0;
								const gchar* _tmp34_ = NULL;
								_tmp33_ = entry;
								_tmp33__length1 = entry_length1;
								_tmp34_ = _tmp33_[1];
								installation_set_keyboard (self, _tmp34_);
								break;
							}
						}
					} else if (_tmp12_ == ((0 != _tmp11_label10) ? _tmp11_label10 : (_tmp11_label10 = g_quark_from_static_string ("autologin")))) {
						switch (0) {
							default:
							{
								gchar** _tmp35_ = NULL;
								gint _tmp35__length1 = 0;
								const gchar* _tmp36_ = NULL;
								_tmp35_ = entry;
								_tmp35__length1 = entry_length1;
								_tmp36_ = _tmp35_[1];
								installation_set_autologin (self, g_strcmp0 (_tmp36_, "true") == 0);
								break;
							}
						}
					}
				}
				entry = (_vala_array_free (entry, entry_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (param);
			}
		}
		param_collection = (_vala_array_free (param_collection, param_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	g_signal_connect_object (self, "installation-started", (GCallback) ___lambda7__installation_installation_started, self, 0);
	self->priv->installation_size = 4 * INSTALLATION_OneGig;
	{
		GFile* file = NULL;
		GFile* _tmp37_ = NULL;
		GFile* _tmp38_ = NULL;
		gboolean _tmp39_ = FALSE;
		_tmp37_ = g_file_new_for_path ("/live/image/.disk/installation_size");
		file = _tmp37_;
		_tmp38_ = file;
		_tmp39_ = g_file_query_exists (_tmp38_, NULL);
		if (_tmp39_) {
			GFileInputStream* _tmp40_ = NULL;
			GFile* _tmp41_ = NULL;
			GFileInputStream* _tmp42_ = NULL;
			GDataInputStream* dis = NULL;
			GDataInputStream* _tmp43_ = NULL;
			gsize l = 0UL;
			gchar* line = NULL;
			GDataInputStream* _tmp44_ = NULL;
			gsize _tmp45_ = 0UL;
			gchar* _tmp46_ = NULL;
			GDataInputStream* _tmp47_ = NULL;
			const gchar* _tmp48_ = NULL;
			_tmp41_ = file;
			_tmp42_ = g_file_read (_tmp41_, NULL, &_inner_error_);
			_tmp40_ = _tmp42_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp43_ = g_data_input_stream_new ((GInputStream*) _tmp40_);
			dis = _tmp43_;
			_tmp44_ = dis;
			_tmp46_ = g_data_input_stream_read_line (_tmp44_, &_tmp45_, NULL, &_inner_error_);
			l = _tmp45_;
			line = _tmp46_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp40_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp47_ = dis;
			g_input_stream_close ((GInputStream*) _tmp47_, NULL, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp40_);
				_g_object_unref0 (file);
				goto __catch1_g_error;
			}
			_tmp48_ = line;
			if (_tmp48_ != NULL) {
				const gchar* _tmp49_ = NULL;
				guint64 _tmp50_ = 0ULL;
				guint64 _tmp51_ = 0ULL;
				_tmp49_ = line;
				_tmp50_ = uint64_parse (_tmp49_);
				self->priv->installation_size = _tmp50_;
				_tmp51_ = self->priv->installation_size;
				if (_tmp51_ <= ((guint64) 0)) {
					self->priv->installation_size = 4 * INSTALLATION_OneGig;
				}
			}
			_g_free0 (line);
			_g_object_unref0 (dis);
			_g_object_unref0 (_tmp40_);
		}
		_g_object_unref0 (file);
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp52_ = NULL;
		GError* _tmp53_ = NULL;
		const gchar* _tmp54_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp52_ = stderr;
		_tmp53_ = e;
		_tmp54_ = _tmp53_->message;
		fprintf (_tmp52_, "%s\n", _tmp54_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


Installation* installation_new_from_string (const gchar* uri) {
	return installation_construct_from_string (TYPE_INSTALLATION, uri);
}


void installation_start (Installation* self) {
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "installation-started");
}


static void installation_real_start (Installation* self) {
	Log* _tmp0_ = NULL;
	Log* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = log_instance ();
	_tmp1_ = _tmp0_;
	log_log (_tmp1_, "START");
	_g_object_unref0 (_tmp1_);
	installation_set_state (self, (gint) INSTALLATION_STATE_ON_GOING);
	installation_do_next_job (self);
}


static void installation_do_next_job (Installation* self) {
	InstallationStep _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->last_step;
	switch (_tmp0_) {
		case INSTALLATION_STEP_IDLE:
		{
			Log* _tmp1_ = NULL;
			Log* _tmp2_ = NULL;
			installation_set_progress (self, 5);
			_tmp1_ = log_instance ();
			_tmp2_ = _tmp1_;
			log_log (_tmp2_, "PARTITION");
			_g_object_unref0 (_tmp2_);
			installation_do_partition (self);
			break;
		}
		case INSTALLATION_STEP_PARTITION:
		{
			Log* _tmp3_ = NULL;
			Log* _tmp4_ = NULL;
			installation_set_progress (self, 10);
			_tmp3_ = log_instance ();
			_tmp4_ = _tmp3_;
			log_log (_tmp4_, "FS");
			_g_object_unref0 (_tmp4_);
			installation_do_fs (self);
			break;
		}
		case INSTALLATION_STEP_FS:
		{
			Log* _tmp5_ = NULL;
			Log* _tmp6_ = NULL;
			_tmp5_ = log_instance ();
			_tmp6_ = _tmp5_;
			log_log (_tmp6_, "MOUNT");
			_g_object_unref0 (_tmp6_);
			installation_do_mount (self);
			break;
		}
		case INSTALLATION_STEP_MOUNT:
		{
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			installation_set_progress (self, 15);
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			log_log (_tmp8_, "COPY");
			_g_object_unref0 (_tmp8_);
			installation_do_copy (self);
			break;
		}
		case INSTALLATION_STEP_COPY:
		{
			Log* _tmp9_ = NULL;
			Log* _tmp10_ = NULL;
			installation_set_progress (self, 80);
			_tmp9_ = log_instance ();
			_tmp10_ = _tmp9_;
			log_log (_tmp10_, "SETUP");
			_g_object_unref0 (_tmp10_);
			installation_do_setup (self);
			break;
		}
		case INSTALLATION_STEP_SETUP:
		{
			Log* _tmp11_ = NULL;
			Log* _tmp12_ = NULL;
			installation_set_progress (self, 90);
			_tmp11_ = log_instance ();
			_tmp12_ = _tmp11_;
			log_log (_tmp12_, "GRUB");
			_g_object_unref0 (_tmp12_);
			installation_do_grub (self);
			break;
		}
		case INSTALLATION_STEP_GRUB:
		{
			Log* _tmp13_ = NULL;
			Log* _tmp14_ = NULL;
			_tmp13_ = log_instance ();
			_tmp14_ = _tmp13_;
			log_log (_tmp14_, "CLEANUP");
			_g_object_unref0 (_tmp14_);
			installation_do_cleanup (self);
			break;
		}
		case INSTALLATION_STEP_CLEANUP:
		{
			Log* _tmp15_ = NULL;
			Log* _tmp16_ = NULL;
			installation_set_progress (self, 100);
			_tmp15_ = log_instance ();
			_tmp16_ = _tmp15_;
			log_log (_tmp16_, "DONE");
			_g_object_unref0 (_tmp16_);
			installation_do_done (self);
			break;
		}
		case INSTALLATION_STEP_DONE:
		{
			gint _tmp17_ = 0;
			_tmp17_ = self->priv->_state;
			if (_tmp17_ != ((gint) INSTALLATION_STATE_ERROR)) {
				Log* _tmp18_ = NULL;
				Log* _tmp19_ = NULL;
				_tmp18_ = log_instance ();
				_tmp19_ = _tmp18_;
				log_log (_tmp19_, "ERROR");
				_g_object_unref0 (_tmp19_);
				installation_set_description (self, "Done");
			} else {
				Log* _tmp20_ = NULL;
				Log* _tmp21_ = NULL;
				_tmp20_ = log_instance ();
				_tmp21_ = _tmp20_;
				log_log (_tmp21_, "DONE");
				_g_object_unref0 (_tmp21_);
			}
			break;
		}
		default:
		break;
	}
}


static void installation_child_watch (Installation* self, GPid pid, gint status) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp1_ = status;
	_tmp2_ = WIFEXITED (_tmp1_);
	if (_tmp2_) {
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		_tmp3_ = status;
		_tmp4_ = WEXITSTATUS (_tmp3_);
		_tmp0_ = _tmp4_ == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp5_ = status;
		_tmp6_ = WEXITSTATUS (_tmp5_);
		if (_tmp6_ == 0) {
			Log* _tmp7_ = NULL;
			Log* _tmp8_ = NULL;
			GPid _tmp9_ = 0;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_ = NULL;
			gchar* _tmp15_ = NULL;
			InstallationStep _tmp16_ = 0;
			_tmp7_ = log_instance ();
			_tmp8_ = _tmp7_;
			_tmp9_ = pid;
			_tmp10_ = g_strdup_printf ("%i", (gint) _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = g_strconcat ("Child ", _tmp11_, NULL);
			_tmp13_ = _tmp12_;
			_tmp14_ = g_strconcat (_tmp13_, " has finished it's task successfuly.", NULL);
			_tmp15_ = _tmp14_;
			log_log (_tmp8_, _tmp15_);
			_g_free0 (_tmp15_);
			_g_free0 (_tmp13_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp8_);
			_tmp16_ = self->priv->step;
			self->priv->last_step = _tmp16_;
			self->priv->step = INSTALLATION_STEP_IDLE;
		} else {
			Log* _tmp17_ = NULL;
			Log* _tmp18_ = NULL;
			GPid _tmp19_ = 0;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_ = NULL;
			gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			gchar* _tmp24_ = NULL;
			gchar* _tmp25_ = NULL;
			gint _tmp26_ = 0;
			gint _tmp27_ = 0;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			gchar* _tmp31_ = NULL;
			_tmp17_ = log_instance ();
			_tmp18_ = _tmp17_;
			_tmp19_ = pid;
			_tmp20_ = g_strdup_printf ("%i", (gint) _tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = g_strconcat ("Child ", _tmp21_, NULL);
			_tmp23_ = _tmp22_;
			_tmp24_ = g_strconcat (_tmp23_, " has ended and return with ", NULL);
			_tmp25_ = _tmp24_;
			_tmp26_ = status;
			_tmp27_ = WEXITSTATUS (_tmp26_);
			_tmp28_ = g_strdup_printf ("%i", _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = g_strconcat (_tmp25_, _tmp29_, NULL);
			_tmp31_ = _tmp30_;
			log_log (_tmp18_, _tmp31_);
			_g_free0 (_tmp31_);
			_g_free0 (_tmp29_);
			_g_free0 (_tmp25_);
			_g_free0 (_tmp23_);
			_g_free0 (_tmp21_);
			_g_object_unref0 (_tmp18_);
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
		}
	} else {
		Log* _tmp32_ = NULL;
		Log* _tmp33_ = NULL;
		GPid _tmp34_ = 0;
		gchar* _tmp35_ = NULL;
		gchar* _tmp36_ = NULL;
		gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		gchar* _tmp39_ = NULL;
		gchar* _tmp40_ = NULL;
		_tmp32_ = log_instance ();
		_tmp33_ = _tmp32_;
		_tmp34_ = pid;
		_tmp35_ = g_strdup_printf ("%i", (gint) _tmp34_);
		_tmp36_ = _tmp35_;
		_tmp37_ = g_strconcat ("Child ", _tmp36_, NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_strconcat (_tmp38_, " has ended and failed.", NULL);
		_tmp40_ = _tmp39_;
		log_log (_tmp33_, _tmp40_);
		_g_free0 (_tmp40_);
		_g_free0 (_tmp38_);
		_g_free0 (_tmp36_);
		_g_object_unref0 (_tmp33_);
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
	}
	installation_do_next_job (self);
}


static void installation_do_simple_command_with_args (Installation* self, gchar** commands_to_run, int commands_to_run_length1, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gint pid = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	pid = 0;
	_tmp0_ = commands_to_run;
	_tmp0__length1 = commands_to_run_length1;
	_tmp1_ = installation_run (self, _tmp0_, _tmp0__length1);
	pid = _tmp1_;
	_tmp2_ = pid;
	if (_tmp2_ != 0) {
		InstallationStep _tmp3_ = 0;
		const gchar* _tmp4_ = NULL;
		_tmp3_ = command_step;
		self->priv->step = _tmp3_;
		_tmp4_ = command_description;
		installation_set_description (self, _tmp4_);
	} else {
		const gchar* _tmp5_ = NULL;
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		_tmp5_ = error_description;
		installation_set_description (self, _tmp5_);
	}
}


static void installation_do_partition (Installation* self) {
	GeeArrayList* d = NULL;
	GeeArrayList* _tmp0_ = NULL;
	gboolean inconsistent = FALSE;
	gboolean _tmp1_ = FALSE;
	GeeArrayList* _tmp2_ = NULL;
	gboolean _tmp24_ = FALSE;
	GeeArrayList* partitions = NULL;
	GeeArrayList* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	gpointer _tmp27_ = NULL;
	Device* _tmp28_ = NULL;
	GeeArrayList* _tmp29_ = NULL;
	GeeArrayList* _tmp30_ = NULL;
	GeeArrayList* _tmp31_ = NULL;
	GeeArrayList* _tmp32_ = NULL;
	GeeArrayList* _tmp33_ = NULL;
	gint _tmp34_ = 0;
	gpointer _tmp35_ = NULL;
	Device* _tmp36_ = NULL;
	gchar* _tmp37_ = NULL;
	GeeArrayList* _tmp38_ = NULL;
	gint _tmp39_ = 0;
	gpointer _tmp40_ = NULL;
	DevicePartition* _tmp41_ = NULL;
	DevicePartitionType _tmp42_ = 0;
	DevicePartitionType _tmp43_ = 0;
	gboolean _tmp44_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = parted_get_devices (TRUE);
	d = _tmp0_;
	inconsistent = FALSE;
	_tmp2_ = d;
	if (_tmp2_ != NULL) {
		gint _tmp3_ = 0;
		GeeArrayList* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp3_ = self->priv->_device;
		_tmp4_ = d;
		_tmp5_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_tmp1_ = _tmp3_ > _tmp6_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		inconsistent = TRUE;
	} else {
		gboolean _tmp7_ = FALSE;
		GeeArrayList* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gpointer _tmp10_ = NULL;
		Device* _tmp11_ = NULL;
		GeeArrayList* _tmp12_ = NULL;
		GeeArrayList* _tmp13_ = NULL;
		gboolean _tmp14_ = FALSE;
		_tmp8_ = d;
		_tmp9_ = self->priv->_device;
		_tmp10_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _tmp9_);
		_tmp11_ = (Device*) _tmp10_;
		_tmp12_ = device_get_partitions (_tmp11_);
		_tmp13_ = _tmp12_;
		_tmp14_ = _tmp13_ != NULL;
		_g_object_unref0 (_tmp11_);
		if (_tmp14_) {
			gint _tmp15_ = 0;
			GeeArrayList* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gpointer _tmp18_ = NULL;
			Device* _tmp19_ = NULL;
			GeeArrayList* _tmp20_ = NULL;
			GeeArrayList* _tmp21_ = NULL;
			gint _tmp22_ = 0;
			gint _tmp23_ = 0;
			_tmp15_ = self->priv->_partition;
			_tmp16_ = d;
			_tmp17_ = self->priv->_device;
			_tmp18_ = gee_abstract_list_get ((GeeAbstractList*) _tmp16_, _tmp17_);
			_tmp19_ = (Device*) _tmp18_;
			_tmp20_ = device_get_partitions (_tmp19_);
			_tmp21_ = _tmp20_;
			_tmp22_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp21_);
			_tmp23_ = _tmp22_;
			_tmp7_ = _tmp15_ > _tmp23_;
			_g_object_unref0 (_tmp19_);
		} else {
			_tmp7_ = FALSE;
		}
		if (_tmp7_) {
			inconsistent = TRUE;
		}
	}
	_tmp24_ = inconsistent;
	if (_tmp24_) {
		self->priv->step = INSTALLATION_STEP_DONE;
		self->priv->last_step = INSTALLATION_STEP_DONE;
		installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
		installation_set_description (self, "Inconsistent partition record");
		_g_object_unref0 (d);
		return;
	}
	_tmp25_ = d;
	_tmp26_ = self->priv->_device;
	_tmp27_ = gee_abstract_list_get ((GeeAbstractList*) _tmp25_, _tmp26_);
	_tmp28_ = (Device*) _tmp27_;
	_tmp29_ = device_get_partitions (_tmp28_);
	_tmp30_ = _tmp29_;
	_tmp31_ = _g_object_ref0 (_tmp30_);
	_tmp32_ = _tmp31_;
	_g_object_unref0 (_tmp28_);
	partitions = _tmp32_;
	_tmp33_ = d;
	_tmp34_ = self->priv->_device;
	_tmp35_ = gee_abstract_list_get ((GeeAbstractList*) _tmp33_, _tmp34_);
	_tmp36_ = (Device*) _tmp35_;
	_tmp37_ = device_get_path (_tmp36_);
	_g_free0 (self->priv->device_path);
	self->priv->device_path = _tmp37_;
	_g_object_unref0 (_tmp36_);
	_tmp38_ = partitions;
	_tmp39_ = self->priv->_partition;
	_tmp40_ = gee_abstract_list_get ((GeeAbstractList*) _tmp38_, _tmp39_);
	_tmp41_ = (DevicePartition*) _tmp40_;
	_tmp42_ = device_partition_get_ptype (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = _tmp43_ == DEVICE_PARTITION_TYPE_FREESPACE;
	_g_object_unref0 (_tmp41_);
	if (_tmp44_) {
		Device* device = NULL;
		const gchar* _tmp45_ = NULL;
		Device* _tmp46_ = NULL;
		gboolean can_continue = FALSE;
		gint new_partition = 0;
		gboolean _tmp96_ = FALSE;
		GeeArrayList* _tmp97_ = NULL;
		GeeArrayList* _tmp98_ = NULL;
		const gchar* _tmp99_ = NULL;
		gint _tmp100_ = 0;
		gchar* _tmp101_ = NULL;
		gchar* _tmp102_ = NULL;
		gchar* _tmp103_ = NULL;
		installation_set_description (self, "Partitioning");
		self->priv->step = INSTALLATION_STEP_PARTITION;
		_tmp45_ = self->priv->device_path;
		_tmp46_ = device_new_from_name (_tmp45_);
		device = _tmp46_;
		can_continue = FALSE;
		new_partition = -1;
		{
			guint64 swap_size = 0ULL;
			GeeArrayList* _tmp47_ = NULL;
			GeeArrayList* _tmp48_ = NULL;
			gboolean _tmp49_ = FALSE;
			gboolean _tmp50_ = FALSE;
			gboolean _tmp51_ = FALSE;
			gint _tmp67_ = 0;
			Device* _tmp68_ = NULL;
			GeeArrayList* _tmp69_ = NULL;
			gint _tmp70_ = 0;
			gpointer _tmp71_ = NULL;
			DevicePartition* _tmp72_ = NULL;
			guint64 _tmp73_ = 0ULL;
			guint64 _tmp74_ = 0ULL;
			GeeArrayList* _tmp75_ = NULL;
			gint _tmp76_ = 0;
			gpointer _tmp77_ = NULL;
			DevicePartition* _tmp78_ = NULL;
			guint64 _tmp79_ = 0ULL;
			guint64 _tmp80_ = 0ULL;
			guint64 _tmp81_ = 0ULL;
			gint _tmp82_ = 0;
			gint _tmp83_ = 0;
			Log* _tmp84_ = NULL;
			Log* _tmp85_ = NULL;
			gint _tmp86_ = 0;
			gchar* _tmp87_ = NULL;
			gchar* _tmp88_ = NULL;
			gchar* _tmp89_ = NULL;
			gchar* _tmp90_ = NULL;
			gint _tmp91_ = 0;
			swap_size = (guint64) 0;
			_tmp47_ = swap_collector_get_partitions ();
			_tmp48_ = _tmp47_;
			_tmp49_ = gee_abstract_collection_get_is_empty ((GeeAbstractCollection*) _tmp48_);
			_tmp50_ = _tmp49_;
			_tmp51_ = _tmp50_;
			_g_object_unref0 (_tmp48_);
			if (_tmp51_) {
				GeeArrayList* _tmp52_ = NULL;
				gint _tmp53_ = 0;
				gpointer _tmp54_ = NULL;
				DevicePartition* _tmp55_ = NULL;
				guint64 _tmp56_ = 0ULL;
				guint64 _tmp57_ = 0ULL;
				guint64 _tmp58_ = 0ULL;
				gboolean _tmp59_ = FALSE;
				_tmp52_ = partitions;
				_tmp53_ = self->priv->_partition;
				_tmp54_ = gee_abstract_list_get ((GeeAbstractList*) _tmp52_, _tmp53_);
				_tmp55_ = (DevicePartition*) _tmp54_;
				_tmp56_ = device_partition_get_size (_tmp55_);
				_tmp57_ = _tmp56_;
				_tmp58_ = self->priv->installation_size;
				_tmp59_ = (_tmp57_ - INSTALLATION_OneGig) > _tmp58_;
				_g_object_unref0 (_tmp55_);
				if (_tmp59_) {
					Log* _tmp60_ = NULL;
					Log* _tmp61_ = NULL;
					guint64 _tmp62_ = 0ULL;
					gchar* _tmp63_ = NULL;
					gchar* _tmp64_ = NULL;
					gchar* _tmp65_ = NULL;
					gchar* _tmp66_ = NULL;
					swap_size = INSTALLATION_OneGig;
					_tmp60_ = log_instance ();
					_tmp61_ = _tmp60_;
					_tmp62_ = swap_size;
					_tmp63_ = g_strdup_printf ("%" G_GUINT64_FORMAT, _tmp62_);
					_tmp64_ = _tmp63_;
					_tmp65_ = g_strconcat ("No swap detected, creating swap along with partition creation, swap si" \
"ze = ", _tmp64_, NULL);
					_tmp66_ = _tmp65_;
					log_log (_tmp61_, _tmp66_);
					_g_free0 (_tmp66_);
					_g_free0 (_tmp64_);
					_g_object_unref0 (_tmp61_);
				}
			}
			swap_size = INSTALLATION_OneGig;
			_tmp68_ = device;
			_tmp69_ = partitions;
			_tmp70_ = self->priv->_partition;
			_tmp71_ = gee_abstract_list_get ((GeeAbstractList*) _tmp69_, _tmp70_);
			_tmp72_ = (DevicePartition*) _tmp71_;
			_tmp73_ = device_partition_get_start (_tmp72_);
			_tmp74_ = _tmp73_;
			_tmp75_ = partitions;
			_tmp76_ = self->priv->_partition;
			_tmp77_ = gee_abstract_list_get ((GeeAbstractList*) _tmp75_, _tmp76_);
			_tmp78_ = (DevicePartition*) _tmp77_;
			_tmp79_ = device_partition_get_end (_tmp78_);
			_tmp80_ = _tmp79_;
			_tmp81_ = swap_size;
			_tmp82_ = device_create_partition (_tmp68_, _tmp74_, _tmp80_, "ext4", _tmp81_, &_inner_error_);
			_tmp83_ = _tmp82_;
			_g_object_unref0 (_tmp78_);
			_g_object_unref0 (_tmp72_);
			_tmp67_ = _tmp83_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == DEVICE_ERROR) {
					goto __catch2_device_error;
				}
				_g_object_unref0 (device);
				_g_object_unref0 (partitions);
				_g_object_unref0 (d);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			new_partition = _tmp67_;
			_tmp84_ = log_instance ();
			_tmp85_ = _tmp84_;
			_tmp86_ = new_partition;
			_tmp87_ = g_strdup_printf ("%i", _tmp86_);
			_tmp88_ = _tmp87_;
			_tmp89_ = g_strconcat ("Partition creation returns new partition ID: ", _tmp88_, NULL);
			_tmp90_ = _tmp89_;
			log_log (_tmp85_, _tmp90_);
			_g_free0 (_tmp90_);
			_g_free0 (_tmp88_);
			_g_object_unref0 (_tmp85_);
			_tmp91_ = new_partition;
			if (_tmp91_ != (-1)) {
				can_continue = TRUE;
			}
		}
		goto __finally2;
		__catch2_device_error:
		{
			GError* e = NULL;
			Log* _tmp92_ = NULL;
			Log* _tmp93_ = NULL;
			GError* _tmp94_ = NULL;
			const gchar* _tmp95_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp92_ = log_instance ();
			_tmp93_ = _tmp92_;
			_tmp94_ = e;
			_tmp95_ = _tmp94_->message;
			log_log_without_newline (_tmp93_, _tmp95_);
			_g_object_unref0 (_tmp93_);
			_g_error_free0 (e);
		}
		__finally2:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (device);
			_g_object_unref0 (partitions);
			_g_object_unref0 (d);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp96_ = can_continue;
		if (_tmp96_ == FALSE) {
			self->priv->step = INSTALLATION_STEP_DONE;
			self->priv->last_step = INSTALLATION_STEP_DONE;
			installation_set_state (self, (gint) INSTALLATION_STATE_ERROR);
			installation_set_description (self, "Error while doing partition");
			_g_object_unref0 (device);
			_g_object_unref0 (partitions);
			_g_object_unref0 (d);
			return;
		}
		_tmp97_ = parted_get_devices (FALSE);
		_tmp98_ = _tmp97_;
		_g_object_unref0 (_tmp98_);
		_tmp99_ = self->priv->device_path;
		_tmp100_ = new_partition;
		_tmp101_ = g_strdup_printf ("%i", _tmp100_);
		_tmp102_ = _tmp101_;
		_tmp103_ = g_strconcat (_tmp99_, _tmp102_, NULL);
		_g_free0 (self->priv->partition_path);
		self->priv->partition_path = _tmp103_;
		_g_free0 (_tmp102_);
		_g_object_unref0 (device);
	} else {
		GeeArrayList* _tmp104_ = NULL;
		gint _tmp105_ = 0;
		gpointer _tmp106_ = NULL;
		Device* _tmp107_ = NULL;
		gchar* _tmp108_ = NULL;
		gchar* _tmp109_ = NULL;
		GeeArrayList* _tmp110_ = NULL;
		gint _tmp111_ = 0;
		gpointer _tmp112_ = NULL;
		DevicePartition* _tmp113_ = NULL;
		gint _tmp114_ = 0;
		gint _tmp115_ = 0;
		gchar* _tmp116_ = NULL;
		gchar* _tmp117_ = NULL;
		gchar* _tmp118_ = NULL;
		_tmp104_ = d;
		_tmp105_ = self->priv->_device;
		_tmp106_ = gee_abstract_list_get ((GeeAbstractList*) _tmp104_, _tmp105_);
		_tmp107_ = (Device*) _tmp106_;
		_tmp108_ = device_get_path (_tmp107_);
		_tmp109_ = _tmp108_;
		_tmp110_ = partitions;
		_tmp111_ = self->priv->_partition;
		_tmp112_ = gee_abstract_list_get ((GeeAbstractList*) _tmp110_, _tmp111_);
		_tmp113_ = (DevicePartition*) _tmp112_;
		_tmp114_ = device_partition_get_number (_tmp113_);
		_tmp115_ = _tmp114_;
		_tmp116_ = g_strdup_printf ("%i", _tmp115_);
		_tmp117_ = _tmp116_;
		_tmp118_ = g_strconcat (_tmp109_, _tmp117_, NULL);
		_g_free0 (self->priv->partition_path);
		self->priv->partition_path = _tmp118_;
		_g_free0 (_tmp117_);
		_g_object_unref0 (_tmp113_);
		_g_free0 (_tmp109_);
		_g_object_unref0 (_tmp107_);
	}
	self->priv->last_step = INSTALLATION_STEP_PARTITION;
	installation_do_next_job (self);
	_g_object_unref0 (partitions);
	_g_object_unref0 (d);
}


static void installation_do_fs (Installation* self) {
	gchar** c = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("/sbin/mkfs.ext4");
	_tmp1_ = self->priv->partition_path;
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = g_new0 (gchar*, 2 + 1);
	_tmp3_[0] = _tmp0_;
	_tmp3_[1] = _tmp2_;
	c = _tmp3_;
	c_length1 = 2;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_FS, "Installing filesystem", "Unable to install filesystem");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_mount (Installation* self) {
	gchar** c = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	g_mkdir ("/target", 0700);
	_tmp0_ = g_strdup ("/bin/mount");
	_tmp1_ = self->priv->partition_path;
	_tmp2_ = g_strdup (_tmp1_);
	_tmp3_ = g_strdup ("/target");
	_tmp4_ = g_new0 (gchar*, 3 + 1);
	_tmp4_[0] = _tmp0_;
	_tmp4_[1] = _tmp2_;
	_tmp4_[2] = _tmp3_;
	c = _tmp4_;
	c_length1 = 3;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_MOUNT, "Mounting filesystem ", "Unable to mount filesystem");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_simple_command (Installation* self, const gchar* command_to_run, InstallationStep command_step, const gchar* command_description, const gchar* error_description) {
	gchar** c = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	InstallationStep _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (command_to_run != NULL);
	g_return_if_fail (command_description != NULL);
	g_return_if_fail (error_description != NULL);
	_tmp0_ = command_to_run;
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_new0 (gchar*, 1 + 1);
	_tmp2_[0] = _tmp1_;
	c = _tmp2_;
	c_length1 = 1;
	_c_size_ = c_length1;
	_tmp3_ = command_step;
	_tmp4_ = command_description;
	_tmp5_ = error_description;
	installation_do_simple_command_with_args (self, c, c_length1, _tmp3_, _tmp4_, _tmp5_);
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
}


static void installation_do_copy (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-copy-fs", INSTALLATION_STEP_COPY, "Copying filesystem", "Unable to copy filesystem");
}


static void installation_do_setup (Installation* self) {
	gchar* content = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* swaps = NULL;
	gchar* _tmp14_ = NULL;
	const gchar* _tmp30_ = NULL;
	gchar* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_user_name;
	_tmp1_ = self->priv->_password;
	_tmp2_ = g_strdup_printf ("%s:%s\n", _tmp0_, _tmp1_);
	content = _tmp2_;
	_tmp3_ = content;
	utils_write_simple_file ("/tmp/user-pass", _tmp3_);
	_tmp4_ = self->priv->_autologin;
	_tmp5_ = self->priv->_user_name;
	_tmp6_ = g_strdup_printf ("%d %s\n", (gint) _tmp4_, _tmp5_);
	_g_free0 (content);
	content = _tmp6_;
	_tmp7_ = content;
	utils_write_simple_file ("/tmp/user-setup", _tmp7_);
	_tmp8_ = self->priv->_full_name;
	_tmp9_ = g_strdup_printf ("%s\n\n\n\n\n", _tmp8_);
	_g_free0 (content);
	content = _tmp9_;
	_tmp10_ = content;
	utils_write_simple_file ("/tmp/user-info", _tmp10_);
	_tmp11_ = self->priv->_host_name;
	_tmp12_ = g_strdup_printf ("%s\n", _tmp11_);
	_g_free0 (content);
	content = _tmp12_;
	_tmp13_ = content;
	utils_write_simple_file ("/tmp/hostname", _tmp13_);
	swap_collector_reset ();
	_tmp14_ = g_strdup ("");
	swaps = _tmp14_;
	{
		GeeArrayList* _p_list = NULL;
		GeeArrayList* _tmp15_ = NULL;
		gint _p_size = 0;
		GeeArrayList* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _p_index = 0;
		_tmp15_ = swap_collector_get_partitions ();
		_p_list = _tmp15_;
		_tmp16_ = _p_list;
		_tmp17_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp16_);
		_tmp18_ = _tmp17_;
		_p_size = _tmp18_;
		_p_index = -1;
		while (TRUE) {
			gint _tmp19_ = 0;
			gint _tmp20_ = 0;
			gint _tmp21_ = 0;
			gchar* p = NULL;
			GeeArrayList* _tmp22_ = NULL;
			gint _tmp23_ = 0;
			gpointer _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			const gchar* _tmp26_ = NULL;
			gchar* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			_tmp19_ = _p_index;
			_p_index = _tmp19_ + 1;
			_tmp20_ = _p_index;
			_tmp21_ = _p_size;
			if (!(_tmp20_ < _tmp21_)) {
				break;
			}
			_tmp22_ = _p_list;
			_tmp23_ = _p_index;
			_tmp24_ = gee_abstract_list_get ((GeeAbstractList*) _tmp22_, _tmp23_);
			p = (gchar*) _tmp24_;
			_tmp25_ = swaps;
			_tmp26_ = p;
			_tmp27_ = g_strconcat (_tmp26_, "\n", NULL);
			_tmp28_ = _tmp27_;
			_tmp29_ = g_strconcat (_tmp25_, _tmp28_, NULL);
			_g_free0 (swaps);
			swaps = _tmp29_;
			_g_free0 (_tmp28_);
			_g_free0 (p);
		}
		_g_object_unref0 (_p_list);
	}
	_tmp30_ = swaps;
	_tmp31_ = g_strdup_printf ("%s", _tmp30_);
	_g_free0 (content);
	content = _tmp31_;
	_tmp32_ = content;
	utils_write_simple_file ("/tmp/swaps", _tmp32_);
	installation_do_simple_command (self, "/sbin/b-i-setup-fs", INSTALLATION_STEP_SETUP, "Setting up", "Unable to setup installation");
	_g_free0 (swaps);
	_g_free0 (content);
}


static void installation_do_grub (Installation* self) {
	gchar* device = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar** c = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar** _tmp8_ = NULL;
	gint c_length1 = 0;
	gint _c_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->device_path;
	_tmp1_ = g_strdup (_tmp0_);
	device = _tmp1_;
	_tmp2_ = device;
	if (g_strcmp0 (_tmp2_, "") == 0) {
		const gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp3_ = self->priv->device_path;
		_tmp4_ = g_strdup (_tmp3_);
		_g_free0 (device);
		device = _tmp4_;
	}
	_tmp5_ = g_strdup ("/sbin/b-i-install-grub");
	_tmp6_ = device;
	_tmp7_ = g_strdup (_tmp6_);
	_tmp8_ = g_new0 (gchar*, 2 + 1);
	_tmp8_[0] = _tmp5_;
	_tmp8_[1] = _tmp7_;
	c = _tmp8_;
	c_length1 = 2;
	_c_size_ = c_length1;
	installation_do_simple_command_with_args (self, c, c_length1, INSTALLATION_STEP_GRUB, "Installing GRUB", "Unable to install GRUB");
	c = (_vala_array_free (c, c_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (device);
}


static void installation_do_cleanup (Installation* self) {
	g_return_if_fail (self != NULL);
	installation_do_simple_command (self, "/sbin/b-i-cleanup", INSTALLATION_STEP_CLEANUP, "Cleaning up", "Unable to properly clean up");
}


static void installation_do_done (Installation* self) {
	g_return_if_fail (self != NULL);
	self->priv->step = INSTALLATION_STEP_DONE;
	self->priv->last_step = INSTALLATION_STEP_DONE;
	installation_set_state (self, (gint) INSTALLATION_STATE_DONE);
	installation_do_next_job (self);
}


static gboolean installation_watch_stderr (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDERR: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_stdout (Installation* self, GIOChannel* gio, GIOCondition condition) {
	gboolean result = FALSE;
	GIOChannel* _tmp0_ = NULL;
	GIOCondition _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	_tmp0_ = gio;
	_tmp1_ = condition;
	_tmp2_ = installation_watch_gio (self, _tmp0_, _tmp1_, "STDOUT: ");
	result = _tmp2_;
	return result;
}


static gboolean installation_watch_gio (Installation* self, GIOChannel* gio, GIOCondition condition, const gchar* prefix) {
	gboolean result = FALSE;
	GIOStatus ret = 0;
	gchar* msg = NULL;
	gsize len = 0UL;
	gboolean _result_ = FALSE;
	GIOCondition _tmp0_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (gio != NULL, FALSE);
	g_return_val_if_fail (prefix != NULL, FALSE);
	_result_ = TRUE;
	_tmp0_ = condition;
	if ((_tmp0_ & G_IO_HUP) == G_IO_HUP) {
		_result_ = FALSE;
	}
	{
		while (TRUE) {
			GIOStatus _tmp1_ = 0;
			GIOChannel* _tmp2_ = NULL;
			gchar* _tmp3_ = NULL;
			gsize _tmp4_ = 0UL;
			GIOStatus _tmp5_ = 0;
			Log* _tmp6_ = NULL;
			Log* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			_tmp2_ = gio;
			_tmp5_ = g_io_channel_read_line (_tmp2_, &_tmp3_, &_tmp4_, NULL, &_inner_error_);
			_g_free0 (msg);
			msg = _tmp3_;
			len = _tmp4_;
			_tmp1_ = _tmp5_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_IO_CHANNEL_ERROR) {
					goto __catch3_g_io_channel_error;
				}
				if (_inner_error_->domain == G_CONVERT_ERROR) {
					goto __catch3_g_convert_error;
				}
				_g_free0 (msg);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			if (!(_tmp1_ == G_IO_STATUS_NORMAL)) {
				break;
			}
			_tmp6_ = log_instance ();
			_tmp7_ = _tmp6_;
			_tmp8_ = prefix;
			_tmp9_ = msg;
			_tmp10_ = g_strconcat (_tmp8_, _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			log_log_without_newline (_tmp7_, _tmp11_);
			_g_free0 (_tmp11_);
			_g_object_unref0 (_tmp7_);
		}
	}
	goto __finally3;
	__catch3_g_io_channel_error:
	{
		GError* e = NULL;
		Log* _tmp12_ = NULL;
		Log* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		GError* _tmp17_ = NULL;
		const gchar* _tmp18_ = NULL;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp12_ = log_instance ();
		_tmp13_ = _tmp12_;
		_tmp14_ = prefix;
		_tmp15_ = g_strconcat (_tmp14_, "Error reading: ", NULL);
		_tmp16_ = _tmp15_;
		_tmp17_ = e;
		_tmp18_ = _tmp17_->message;
		_tmp19_ = g_strconcat (_tmp16_, _tmp18_, NULL);
		_tmp20_ = _tmp19_;
		log_log (_tmp13_, _tmp20_);
		_g_free0 (_tmp20_);
		_g_free0 (_tmp16_);
		_g_object_unref0 (_tmp13_);
		_g_error_free0 (e);
	}
	goto __finally3;
	__catch3_g_convert_error:
	{
		GError* e = NULL;
		Log* _tmp21_ = NULL;
		Log* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		GError* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		gchar* _tmp29_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp21_ = log_instance ();
		_tmp22_ = _tmp21_;
		_tmp23_ = prefix;
		_tmp24_ = g_strconcat (_tmp23_, "Error reading: ", NULL);
		_tmp25_ = _tmp24_;
		_tmp26_ = e;
		_tmp27_ = _tmp26_->message;
		_tmp28_ = g_strconcat (_tmp25_, _tmp27_, NULL);
		_tmp29_ = _tmp28_;
		log_log (_tmp22_, _tmp29_);
		_g_free0 (_tmp29_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp22_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (msg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = _result_;
	_g_free0 (msg);
	return result;
}


static void _installation_child_watch_gchild_watch_func (GPid pid, gint status, gpointer self) {
	installation_child_watch ((Installation*) self, pid, status);
}


static gboolean _installation_watch_stdout_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stdout ((Installation*) self, source, condition);
	return result;
}


static gboolean _installation_watch_stderr_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = installation_watch_stderr ((Installation*) self, source, condition);
	return result;
}


static gint installation_run (Installation* self, gchar** command, int command_length1) {
	gint result = 0;
	gchar** env = NULL;
	gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* cmd_log = NULL;
	gchar* _tmp2_ = NULL;
	gchar** _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gint fd_out = 0;
	gint fd_err = 0;
	gint child_pid = 0;
	Log* _tmp12_ = NULL;
	Log* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	guint w = 0U;
	gint _tmp26_ = 0;
	guint _tmp27_ = 0U;
	Log* _tmp28_ = NULL;
	Log* _tmp29_ = NULL;
	gint _tmp30_ = 0;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	gchar* _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	guint _tmp37_ = 0U;
	gchar* _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	gchar* _tmp40_ = NULL;
	gchar* _tmp41_ = NULL;
	gint _tmp42_ = 0;
	GIOChannel* _tmp43_ = NULL;
	gint _tmp44_ = 0;
	GIOChannel* _tmp45_ = NULL;
	GIOChannel* _tmp46_ = NULL;
	guint _tmp47_ = 0U;
	GIOChannel* _tmp50_ = NULL;
	guint _tmp51_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_strdup ("LC_ALL=C");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	env = _tmp1_;
	env_length1 = 1;
	_env_size_ = env_length1;
	_tmp2_ = g_strdup ("Running command: '");
	cmd_log = _tmp2_;
	_tmp3_ = command;
	_tmp3__length1 = command_length1;
	{
		gchar** c_collection = NULL;
		gint c_collection_length1 = 0;
		gint _c_collection_size_ = 0;
		gint c_it = 0;
		c_collection = _tmp3_;
		c_collection_length1 = _tmp3__length1;
		for (c_it = 0; c_it < _tmp3__length1; c_it = c_it + 1) {
			gchar* _tmp4_ = NULL;
			gchar* c = NULL;
			_tmp4_ = g_strdup (c_collection[c_it]);
			c = _tmp4_;
			{
				const gchar* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				gchar* _tmp7_ = NULL;
				gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp5_ = cmd_log;
				_tmp6_ = c;
				_tmp7_ = g_strconcat (_tmp6_, " ", NULL);
				_tmp8_ = _tmp7_;
				_tmp9_ = g_strconcat (_tmp5_, _tmp8_, NULL);
				_g_free0 (cmd_log);
				cmd_log = _tmp9_;
				_g_free0 (_tmp8_);
				_g_free0 (c);
			}
		}
	}
	_tmp10_ = cmd_log;
	_tmp11_ = g_strconcat (_tmp10_, "'", NULL);
	_g_free0 (cmd_log);
	cmd_log = _tmp11_;
	_tmp12_ = log_instance ();
	_tmp13_ = _tmp12_;
	_tmp14_ = cmd_log;
	log_log (_tmp13_, _tmp14_);
	_g_object_unref0 (_tmp13_);
	{
		gchar** _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		gchar** _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		GPid _tmp17_ = 0;
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		_tmp15_ = command;
		_tmp15__length1 = command_length1;
		_tmp16_ = env;
		_tmp16__length1 = env_length1;
		g_spawn_async_with_pipes ("/tmp/", _tmp15_, _tmp16_, G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp17_, NULL, &_tmp18_, &_tmp19_, &_inner_error_);
		child_pid = (gint) _tmp17_;
		fd_out = _tmp18_;
		fd_err = _tmp19_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		Log* _tmp20_ = NULL;
		Log* _tmp21_ = NULL;
		GError* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		gchar* _tmp25_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp20_ = log_instance ();
		_tmp21_ = _tmp20_;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		_tmp24_ = g_strconcat ("Error running: ", _tmp23_, NULL);
		_tmp25_ = _tmp24_;
		log_log (_tmp21_, _tmp25_);
		_g_free0 (_tmp25_);
		_g_object_unref0 (_tmp21_);
		result = -1;
		_g_error_free0 (e);
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp26_ = child_pid;
	_tmp27_ = g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, (GPid) _tmp26_, _installation_child_watch_gchild_watch_func, g_object_ref (self), g_object_unref);
	w = _tmp27_;
	_tmp28_ = log_instance ();
	_tmp29_ = _tmp28_;
	_tmp30_ = child_pid;
	_tmp31_ = g_strdup_printf ("%i", _tmp30_);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat ("Child is spawn with PID: ", _tmp32_, NULL);
	_tmp34_ = _tmp33_;
	_tmp35_ = g_strconcat (_tmp34_, " and watched as ", NULL);
	_tmp36_ = _tmp35_;
	_tmp37_ = w;
	_tmp38_ = g_strdup_printf ("%u", _tmp37_);
	_tmp39_ = _tmp38_;
	_tmp40_ = g_strconcat (_tmp36_, _tmp39_, NULL);
	_tmp41_ = _tmp40_;
	log_log (_tmp29_, _tmp41_);
	_g_free0 (_tmp41_);
	_g_free0 (_tmp39_);
	_g_free0 (_tmp36_);
	_g_free0 (_tmp34_);
	_g_free0 (_tmp32_);
	_g_object_unref0 (_tmp29_);
	_tmp42_ = fd_out;
	_tmp43_ = g_io_channel_unix_new (_tmp42_);
	_g_io_channel_unref0 (self->priv->io_out);
	self->priv->io_out = _tmp43_;
	_tmp44_ = fd_err;
	_tmp45_ = g_io_channel_unix_new (_tmp44_);
	_g_io_channel_unref0 (self->priv->io_err);
	self->priv->io_err = _tmp45_;
	_tmp46_ = self->priv->io_out;
	_tmp47_ = g_io_add_watch (_tmp46_, G_IO_IN | G_IO_HUP, _installation_watch_stdout_gio_func, self);
	if (!(_tmp47_ != ((guint) 0))) {
		Log* _tmp48_ = NULL;
		Log* _tmp49_ = NULL;
		_tmp48_ = log_instance ();
		_tmp49_ = _tmp48_;
		log_log (_tmp49_, "Error watching stdout for cmd_log");
		_g_object_unref0 (_tmp49_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp50_ = self->priv->io_err;
	_tmp51_ = g_io_add_watch (_tmp50_, G_IO_IN | G_IO_HUP, _installation_watch_stderr_gio_func, self);
	if (!(_tmp51_ != ((guint) 0))) {
		Log* _tmp52_ = NULL;
		Log* _tmp53_ = NULL;
		_tmp52_ = log_instance ();
		_tmp53_ = _tmp52_;
		log_log (_tmp53_, "Error watching stderr for cmd_log");
		_g_object_unref0 (_tmp53_);
		result = -1;
		_g_free0 (cmd_log);
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = child_pid;
	_g_free0 (cmd_log);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static void* _installation_js_get_status_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_get_status (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


static void* _installation_js_start_js_core_object_call_as_function_callback (void* ctx, void* function, void* thisObject, size_t arguments_length1, void** arguments, void** exception) {
	void* result;
	result = installation_js_start (ctx, function, thisObject, arguments, arguments_length1, exception);
	return result;
}


void* installation_js_constructor (void* ctx, void* constructor, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* s = NULL;
	void* _tmp4_ = NULL;
	void* f = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	void* _tmp8_ = NULL;
	void* _tmp9_ = NULL;
	void* _tmp10_ = NULL;
	void* _tmp11_ = NULL;
	void* _tmp12_ = NULL;
	void* _tmp13_ = NULL;
	void* _tmp14_ = NULL;
	void* _tmp15_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	void* _tmp19_ = NULL;
	void** _tmp20_ = NULL;
	gint _tmp20__length1 = 0;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (constructor != NULL, NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = ctx;
	_tmp2_ = c;
	_tmp3_ = JSObjectMake (_tmp1_, _tmp2_, NULL);
	o = _tmp3_;
	_tmp4_ = JSStringCreateWithUTF8CString ("getStatus");
	s = _tmp4_;
	_tmp5_ = ctx;
	_tmp6_ = s;
	_tmp7_ = JSObjectMakeFunctionWithCallback (_tmp5_, _tmp6_, _installation_js_get_status_js_core_object_call_as_function_callback);
	f = _tmp7_;
	_tmp8_ = o;
	_tmp9_ = ctx;
	_tmp10_ = s;
	_tmp11_ = f;
	JSObjectSetProperty (_tmp9_, _tmp8_, _tmp10_, _tmp11_, 0, NULL);
	_tmp12_ = JSStringCreateWithUTF8CString ("start");
	_JSStringRelease0 (s);
	s = _tmp12_;
	_tmp13_ = ctx;
	_tmp14_ = s;
	_tmp15_ = JSObjectMakeFunctionWithCallback (_tmp13_, _tmp14_, _installation_js_start_js_core_object_call_as_function_callback);
	_0 (f);
	f = _tmp15_;
	_tmp16_ = o;
	_tmp17_ = ctx;
	_tmp18_ = s;
	_tmp19_ = f;
	JSObjectSetProperty (_tmp17_, _tmp16_, _tmp18_, _tmp19_, 0, NULL);
	_tmp20_ = arguments;
	_tmp20__length1 = arguments_length1;
	if (_tmp20__length1 == 1) {
		void** _tmp21_ = NULL;
		gint _tmp21__length1 = 0;
		void* _tmp22_ = NULL;
		void* _tmp23_ = NULL;
		void* _tmp24_ = NULL;
		gchar buffer[1024] = {0};
		void* _tmp25_ = NULL;
		Installation* i = NULL;
		Installation* _tmp26_ = NULL;
		void* _tmp27_ = NULL;
		Installation* _tmp28_ = NULL;
		_tmp21_ = arguments;
		_tmp21__length1 = arguments_length1;
		_tmp22_ = _tmp21_[0];
		_tmp23_ = ctx;
		_tmp24_ = JSValueToStringCopy (_tmp23_, _tmp22_, NULL);
		_JSStringRelease0 (s);
		s = _tmp24_;
		_tmp25_ = s;
		JSStringGetUTF8CString (_tmp25_, buffer, (gsize) 1024);
		_tmp26_ = installation_new_from_string ((const gchar*) buffer);
		i = _tmp26_;
		_tmp27_ = o;
		_tmp28_ = i;
		JSObjectSetPrivate (_tmp27_, _tmp28_);
	}
	result = o;
	_0 (f);
	_JSStringRelease0 (s);
	_JSClassRelease0 (c);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_status (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp16_ = NULL;
	void* _tmp17_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		gchar* _result_ = NULL;
		Installation* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		Installation* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		Installation* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gchar* _tmp10_ = NULL;
		void* s = NULL;
		const gchar* _tmp11_ = NULL;
		void* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		_tmp4_ = i;
		_tmp5_ = _tmp4_->priv->_state;
		_tmp6_ = i;
		_tmp7_ = _tmp6_->priv->_description;
		_tmp8_ = i;
		_tmp9_ = _tmp8_->priv->_progress;
		_tmp10_ = g_strdup_printf ("({ 'status': %d, 'description': '%s', 'progress': %d })", _tmp5_, _tmp7_, _tmp9_);
		_result_ = _tmp10_;
		_tmp11_ = _result_;
		_tmp12_ = JSStringCreateWithUTF8CString (_tmp11_);
		s = _tmp12_;
		_tmp13_ = ctx;
		_tmp14_ = s;
		_tmp15_ = JSEvaluateScript (_tmp13_, _tmp14_, NULL, NULL, 0, NULL);
		result = _tmp15_;
		_JSStringRelease0 (s);
		_g_free0 (_result_);
		_g_object_unref0 (i);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp16_ = ctx;
	_tmp17_ = JSValueMakeUndefined (_tmp16_);
	result = _tmp17_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_start (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	Installation* i = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	Installation* _tmp2_ = NULL;
	Installation* _tmp3_ = NULL;
	void* _tmp5_ = NULL;
	void* _tmp6_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = thisObject;
	_tmp1_ = JSObjectGetPrivate (_tmp0_);
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp1_, TYPE_INSTALLATION) ? ((Installation*) _tmp1_) : NULL);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ != NULL) {
		Installation* _tmp4_ = NULL;
		_tmp4_ = i;
		installation_start (_tmp4_);
	}
	_tmp5_ = ctx;
	_tmp6_ = JSValueMakeUndefined (_tmp5_);
	result = _tmp6_;
	_g_object_unref0 (i);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_shutdown (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	gtk_main_quit ();
	_tmp0_ = ctx;
	_tmp1_ = JSValueMakeUndefined (_tmp0_);
	result = _tmp1_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_reboot (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* location = NULL;
	gchar* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_tmp0_ = g_strdup ("/tmp/post-install.sh");
	location = _tmp0_;
	utils_write_simple_file (location, "sudo /sbin/reboot\n");
	gtk_main_quit ();
	_tmp1_ = ctx;
	_tmp2_ = JSValueMakeUndefined (_tmp1_);
	result = _tmp2_;
	_g_free0 (location);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_translate (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp17_ = NULL;
	void* _tmp18_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		void* _tmp13_ = NULL;
		void* _result_ = NULL;
		void* _tmp14_ = NULL;
		void* _tmp15_ = NULL;
		void* _tmp16_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = _ ((const gchar*) _tmp11_);
		_tmp13_ = JSStringCreateWithUTF8CString (_tmp12_);
		_JSStringRelease0 (s);
		s = _tmp13_;
		_tmp14_ = ctx;
		_tmp15_ = s;
		_tmp16_ = JSValueMakeString (_tmp14_, _tmp15_);
		_result_ = _tmp16_;
		_JSStringRelease0 (s);
		s = NULL;
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		result = _result_;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
		if (exception) {
			*exception = _vala_exception;
		} else {
			_0 (_vala_exception);
		}
		return result;
	}
	_tmp17_ = ctx;
	_tmp18_ = JSValueMakeUndefined (_tmp17_);
	result = _tmp18_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_timezone (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp19_ = NULL;
	void* _tmp20_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		FILE* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		gint _tmp12__length1 = 0;
		gchar* _tmp13_ = NULL;
		gint _tmp13__length1 = 0;
		gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		gint _tmp16__length1 = 0;
		gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = stdout;
		_tmp12_ = buffer;
		_tmp12__length1 = buffer_length1;
		fprintf (_tmp11_, "Changing timezone to %s\n", (const gchar*) _tmp12_);
		g_unlink ("/etc/localtime");
		_tmp13_ = buffer;
		_tmp13__length1 = buffer_length1;
		_tmp14_ = g_strdup_printf ("/usr/share/zoneinfo/%s", (const gchar*) _tmp13_);
		_tmp15_ = _tmp14_;
		symlink (_tmp15_, "/etc/localtime");
		_g_free0 (_tmp15_);
		_tmp16_ = buffer;
		_tmp16__length1 = buffer_length1;
		_tmp17_ = g_strdup_printf ("TZ=%s\nexport TZ\n", (const gchar*) _tmp16_);
		_tmp18_ = _tmp17_;
		utils_write_simple_file ("/run/timezone", _tmp18_);
		_g_free0 (_tmp18_);
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp19_ = ctx;
	_tmp20_ = JSValueMakeUndefined (_tmp19_);
	result = _tmp20_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_set_locale (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	void** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	void* _tmp21_ = NULL;
	void* _tmp22_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = arguments;
	_tmp0__length1 = arguments_length1;
	if (_tmp0__length1 == 1) {
		void* s = NULL;
		void** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		void* _tmp2_ = NULL;
		void* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		gchar* buffer = NULL;
		void* _tmp5_ = NULL;
		gsize _tmp6_ = 0UL;
		gchar* _tmp7_ = NULL;
		gint buffer_length1 = 0;
		gint _buffer_size_ = 0;
		void* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gint _tmp9__length1 = 0;
		gchar* _tmp10_ = NULL;
		gint _tmp10__length1 = 0;
		gchar* x = NULL;
		gchar* _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		FILE* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		gint _tmp15__length1 = 0;
		const gchar* _tmp16_ = NULL;
		gchar* _tmp17_ = NULL;
		gint _tmp17__length1 = 0;
		gchar* _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		gchar* _tmp19_ = NULL;
		gchar* _tmp20_ = NULL;
		_tmp1_ = arguments;
		_tmp1__length1 = arguments_length1;
		_tmp2_ = _tmp1_[0];
		_tmp3_ = ctx;
		_tmp4_ = JSValueToStringCopy (_tmp3_, _tmp2_, NULL);
		s = _tmp4_;
		_tmp5_ = s;
		_tmp6_ = JSStringGetLength (_tmp5_);
		_tmp7_ = g_new0 (gchar, _tmp6_ + 1);
		buffer = _tmp7_;
		buffer_length1 = _tmp6_ + 1;
		_buffer_size_ = buffer_length1;
		_tmp8_ = s;
		_tmp9_ = buffer;
		_tmp9__length1 = buffer_length1;
		_tmp10_ = buffer;
		_tmp10__length1 = buffer_length1;
		JSStringGetUTF8CString (_tmp8_, _tmp9_, (gsize) _tmp10__length1);
		_tmp11_ = buffer;
		_tmp11__length1 = buffer_length1;
		_tmp12_ = setlocale (LC_ALL, (const gchar*) _tmp11_);
		_tmp13_ = g_strdup (_tmp12_);
		x = _tmp13_;
		_tmp14_ = stdout;
		_tmp15_ = buffer;
		_tmp15__length1 = buffer_length1;
		_tmp16_ = x;
		fprintf (_tmp14_, "Changing locale to %s: %s\n", (const gchar*) _tmp15_, _tmp16_);
		bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
		bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
		textdomain (GETTEXT_PACKAGE);
		_tmp17_ = buffer;
		_tmp17__length1 = buffer_length1;
		_tmp18_ = buffer;
		_tmp18__length1 = buffer_length1;
		_tmp19_ = g_strdup_printf ("LC_ALL=%s\nLANG=%s\n", (const gchar*) _tmp17_, (const gchar*) _tmp18_);
		_tmp20_ = _tmp19_;
		utils_write_simple_file ("/run/locale", _tmp20_);
		_g_free0 (_tmp20_);
		buffer = (g_free (buffer), NULL);
		buffer = NULL;
		buffer_length1 = 0;
		_buffer_size_ = buffer_length1;
		_g_free0 (x);
		buffer = (g_free (buffer), NULL);
		_JSStringRelease0 (s);
	}
	_tmp21_ = ctx;
	_tmp22_ = JSValueMakeUndefined (_tmp21_);
	result = _tmp22_;
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void* installation_js_get_locale_list (void* ctx, void* function, void* thisObject, void** arguments, int arguments_length1, void** exception) {
	void* _vala_exception = NULL;
	void* result = NULL;
	gchar* normal_output = NULL;
	gchar* error_output = NULL;
	gint status = 0;
	gchar** args = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint args_length1 = 0;
	gint _args_size_ = 0;
	gchar** env = NULL;
	gchar* _tmp3_ = NULL;
	gchar** _tmp4_ = NULL;
	gint env_length1 = 0;
	gint _env_size_ = 0;
	gchar* _result_ = NULL;
	gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gchar** _tmp12_ = NULL;
	gchar** _tmp13_ = NULL;
	const gchar* _tmp29_ = NULL;
	gchar* _tmp30_ = NULL;
	void* s = NULL;
	const gchar* _tmp31_ = NULL;
	void* _tmp32_ = NULL;
	void* _tmp33_ = NULL;
	void* _tmp34_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ctx != NULL, NULL);
	g_return_val_if_fail (function != NULL, NULL);
	g_return_val_if_fail (thisObject != NULL, NULL);
	_0 (_vala_exception);
	_vala_exception = NULL;
	_tmp0_ = g_strdup ("/usr/bin/locale");
	_tmp1_ = g_strdup ("-a");
	_tmp2_ = g_new0 (gchar*, 2 + 1);
	_tmp2_[0] = _tmp0_;
	_tmp2_[1] = _tmp1_;
	args = _tmp2_;
	args_length1 = 2;
	_args_size_ = args_length1;
	_tmp3_ = g_strdup ("LC_ALL=C");
	_tmp4_ = g_new0 (gchar*, 1 + 1);
	_tmp4_[0] = _tmp3_;
	env = _tmp4_;
	env_length1 = 1;
	_env_size_ = env_length1;
	{
		gchar** _tmp5_ = NULL;
		gint _tmp5__length1 = 0;
		gchar** _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		_tmp5_ = args;
		_tmp5__length1 = args_length1;
		_tmp6_ = env;
		_tmp6__length1 = env_length1;
		g_spawn_sync ("/tmp", _tmp5_, _tmp6_, G_SPAWN_LEAVE_DESCRIPTORS_OPEN, NULL, NULL, &_tmp7_, &_tmp8_, &_tmp9_, &_inner_error_);
		_g_free0 (normal_output);
		normal_output = _tmp7_;
		_g_free0 (error_output);
		error_output = _tmp8_;
		status = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
		args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (error_output);
		_g_free0 (normal_output);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp10_ = g_strdup ("[");
	_result_ = _tmp10_;
	_tmp11_ = normal_output;
	_tmp13_ = _tmp12_ = g_strsplit (_tmp11_, "\n", 0);
	{
		gchar** line_collection = NULL;
		gint line_collection_length1 = 0;
		gint _line_collection_size_ = 0;
		gint line_it = 0;
		line_collection = _tmp13_;
		line_collection_length1 = _vala_array_length (_tmp12_);
		for (line_it = 0; line_it < _vala_array_length (_tmp12_); line_it = line_it + 1) {
			gchar* _tmp14_ = NULL;
			gchar* line = NULL;
			_tmp14_ = g_strdup (line_collection[line_it]);
			line = _tmp14_;
			{
				const gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				gboolean _tmp17_ = FALSE;
				const gchar* _tmp18_ = NULL;
				_tmp15_ = line;
				if (g_strcmp0 (_tmp15_, "") == 0) {
					_g_free0 (line);
					continue;
				}
				_tmp18_ = line;
				if (g_strcmp0 (_tmp18_, "C") == 0) {
					_tmp17_ = TRUE;
				} else {
					const gchar* _tmp19_ = NULL;
					gboolean _tmp20_ = FALSE;
					_tmp19_ = line;
					_tmp20_ = g_str_has_prefix (_tmp19_, "C.");
					_tmp17_ = _tmp20_;
				}
				if (_tmp17_) {
					_tmp16_ = TRUE;
				} else {
					const gchar* _tmp21_ = NULL;
					_tmp21_ = line;
					_tmp16_ = g_strcmp0 (_tmp21_, "POSIX") == 0;
				}
				if (!_tmp16_) {
					const gchar* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					gchar* _tmp24_ = NULL;
					gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					gchar* _tmp27_ = NULL;
					gchar* _tmp28_ = NULL;
					_tmp22_ = _result_;
					_tmp23_ = line;
					_tmp24_ = g_strconcat ("'", _tmp23_, NULL);
					_tmp25_ = _tmp24_;
					_tmp26_ = g_strconcat (_tmp25_, "',", NULL);
					_tmp27_ = _tmp26_;
					_tmp28_ = g_strconcat (_tmp22_, _tmp27_, NULL);
					_g_free0 (_result_);
					_result_ = _tmp28_;
					_g_free0 (_tmp27_);
					_g_free0 (_tmp25_);
				}
				_g_free0 (line);
			}
		}
		line_collection = (_vala_array_free (line_collection, line_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_tmp29_ = _result_;
	_tmp30_ = g_strconcat (_tmp29_, "'C']", NULL);
	_g_free0 (_result_);
	_result_ = _tmp30_;
	_tmp31_ = _result_;
	_tmp32_ = JSStringCreateWithUTF8CString (_tmp31_);
	s = _tmp32_;
	_tmp33_ = ctx;
	_tmp34_ = JSEvaluateScript (_tmp33_, s, NULL, NULL, 0, NULL);
	result = _tmp34_;
	_JSStringRelease0 (s);
	_g_free0 (_result_);
	env = (_vala_array_free (env, env_length1, (GDestroyNotify) g_free), NULL);
	args = (_vala_array_free (args, args_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (error_output);
	_g_free0 (normal_output);
	if (exception) {
		*exception = _vala_exception;
	} else {
		_0 (_vala_exception);
	}
	return result;
}


void installation_setup_js_class (void* context) {
	void* c = NULL;
	void* _tmp0_ = NULL;
	void* o = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	void* _tmp3_ = NULL;
	void* g = NULL;
	void* _tmp4_ = NULL;
	void* _tmp5_ = NULL;
	void* s = NULL;
	void* _tmp6_ = NULL;
	void* _tmp7_ = NULL;
	g_return_if_fail (context != NULL);
	_tmp0_ = JSClassCreate (&INSTALLATION_js_class);
	c = _tmp0_;
	_tmp1_ = context;
	_tmp2_ = context;
	_tmp3_ = JSObjectMake (_tmp1_, c, _tmp2_);
	o = _tmp3_;
	_tmp4_ = context;
	_tmp5_ = JSContextGetGlobalObject (_tmp4_);
	g = _tmp5_;
	_tmp6_ = JSStringCreateWithUTF8CString ("Installation");
	s = _tmp6_;
	_tmp7_ = context;
	JSObjectSetProperty (_tmp7_, g, s, o, kJSPropertyAttributeNone, NULL);
	_JSStringRelease0 (s);
	_0 (g);
	_0 (o);
	_JSClassRelease0 (c);
}


Installation* installation_construct (GType object_type) {
	Installation * self = NULL;
	self = (Installation*) g_object_new (object_type, NULL);
	return self;
}


Installation* installation_new (void) {
	return installation_construct (TYPE_INSTALLATION);
}


gint installation_get_partition (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_partition;
	result = _tmp0_;
	return result;
}


void installation_set_partition (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_partition = _tmp0_;
	g_object_notify ((GObject *) self, "partition");
}


gint installation_get_device (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_device;
	result = _tmp0_;
	return result;
}


void installation_set_device (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_device = _tmp0_;
	g_object_notify ((GObject *) self, "device");
}


const gchar* installation_get_user_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user_name;
	result = _tmp0_;
	return result;
}


void installation_set_user_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_user_name);
	self->priv->_user_name = _tmp1_;
	g_object_notify ((GObject *) self, "user-name");
}


const gchar* installation_get_password (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_password;
	result = _tmp0_;
	return result;
}


void installation_set_password (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_password);
	self->priv->_password = _tmp1_;
	g_object_notify ((GObject *) self, "password");
}


const gchar* installation_get_host_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_host_name;
	result = _tmp0_;
	return result;
}


void installation_set_host_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_host_name);
	self->priv->_host_name = _tmp1_;
	g_object_notify ((GObject *) self, "host-name");
}


const gchar* installation_get_full_name (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_full_name;
	result = _tmp0_;
	return result;
}


void installation_set_full_name (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_full_name);
	self->priv->_full_name = _tmp1_;
	g_object_notify ((GObject *) self, "full-name");
}


const gchar* installation_get_grub_device (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_grub_device;
	result = _tmp0_;
	return result;
}


void installation_set_grub_device (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_grub_device);
	self->priv->_grub_device = _tmp1_;
	g_object_notify ((GObject *) self, "grub-device");
}


const gchar* installation_get_language (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_language;
	result = _tmp0_;
	return result;
}


void installation_set_language (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_language);
	self->priv->_language = _tmp1_;
	g_object_notify ((GObject *) self, "language");
}


const gchar* installation_get_region (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_region;
	result = _tmp0_;
	return result;
}


void installation_set_region (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_region);
	self->priv->_region = _tmp1_;
	g_object_notify ((GObject *) self, "region");
}


const gchar* installation_get_keyboard (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_keyboard;
	result = _tmp0_;
	return result;
}


void installation_set_keyboard (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_keyboard);
	self->priv->_keyboard = _tmp1_;
	g_object_notify ((GObject *) self, "keyboard");
}


gboolean installation_get_autologin (Installation* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_autologin;
	result = _tmp0_;
	return result;
}


void installation_set_autologin (Installation* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_autologin = _tmp0_;
	g_object_notify ((GObject *) self, "autologin");
}


gint installation_get_state (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_state;
	result = _tmp0_;
	return result;
}


void installation_set_state (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_state = _tmp0_;
	g_object_notify ((GObject *) self, "state");
}


gint installation_get_progress (Installation* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_progress;
	result = _tmp0_;
	return result;
}


static void installation_set_progress (Installation* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_progress = _tmp0_;
	g_object_notify ((GObject *) self, "progress");
}


const gchar* installation_get_description (Installation* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


void installation_set_description (Installation* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


static void installation_class_init (InstallationClass * klass) {
	installation_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallationPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_installation_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_installation_set_property;
	G_OBJECT_CLASS (klass)->finalize = installation_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PARTITION, g_param_spec_int ("partition", "partition", "partition", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DEVICE, g_param_spec_int ("device", "device", "device", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_USER_NAME, g_param_spec_string ("user-name", "user-name", "user-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PASSWORD, g_param_spec_string ("password", "password", "password", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_HOST_NAME, g_param_spec_string ("host-name", "host-name", "host-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_FULL_NAME, g_param_spec_string ("full-name", "full-name", "full-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_GRUB_DEVICE, g_param_spec_string ("grub-device", "grub-device", "grub-device", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_LANGUAGE, g_param_spec_string ("language", "language", "language", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_REGION, g_param_spec_string ("region", "region", "region", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_KEYBOARD, g_param_spec_string ("keyboard", "keyboard", "keyboard", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_AUTOLOGIN, g_param_spec_boolean ("autologin", "autologin", "autologin", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_STATE, g_param_spec_int ("state", "state", "state", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_PROGRESS, g_param_spec_int ("progress", "progress", "progress", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), INSTALLATION_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_signal_new ("installation_started", TYPE_INSTALLATION, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void installation_instance_init (Installation * self) {
	self->priv = INSTALLATION_GET_PRIVATE (self);
	self->priv->step = INSTALLATION_STEP_IDLE;
	self->priv->last_step = INSTALLATION_STEP_IDLE;
}


static void installation_finalize (GObject* obj) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLATION, Installation);
	_g_free0 (self->priv->_user_name);
	_g_free0 (self->priv->_password);
	_g_free0 (self->priv->_host_name);
	_g_free0 (self->priv->_full_name);
	_g_free0 (self->priv->_grub_device);
	_g_free0 (self->priv->_language);
	_g_free0 (self->priv->_region);
	_g_free0 (self->priv->_keyboard);
	_g_free0 (self->priv->_description);
	_g_free0 (self->priv->partition_path);
	_g_free0 (self->priv->device_path);
	_g_io_channel_unref0 (self->priv->io_err);
	_g_io_channel_unref0 (self->priv->io_out);
	G_OBJECT_CLASS (installation_parent_class)->finalize (obj);
}


GType installation_get_type (void) {
	static volatile gsize installation_type_id__volatile = 0;
	if (g_once_init_enter (&installation_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installation_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installation), 0, (GInstanceInitFunc) installation_instance_init, NULL };
		GType installation_type_id;
		installation_type_id = g_type_register_static (G_TYPE_OBJECT, "Installation", &g_define_type_info, 0);
		g_once_init_leave (&installation_type_id__volatile, installation_type_id);
	}
	return installation_type_id__volatile;
}


static void _vala_installation_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		g_value_set_int (value, installation_get_partition (self));
		break;
		case INSTALLATION_DEVICE:
		g_value_set_int (value, installation_get_device (self));
		break;
		case INSTALLATION_USER_NAME:
		g_value_set_string (value, installation_get_user_name (self));
		break;
		case INSTALLATION_PASSWORD:
		g_value_set_string (value, installation_get_password (self));
		break;
		case INSTALLATION_HOST_NAME:
		g_value_set_string (value, installation_get_host_name (self));
		break;
		case INSTALLATION_FULL_NAME:
		g_value_set_string (value, installation_get_full_name (self));
		break;
		case INSTALLATION_GRUB_DEVICE:
		g_value_set_string (value, installation_get_grub_device (self));
		break;
		case INSTALLATION_LANGUAGE:
		g_value_set_string (value, installation_get_language (self));
		break;
		case INSTALLATION_REGION:
		g_value_set_string (value, installation_get_region (self));
		break;
		case INSTALLATION_KEYBOARD:
		g_value_set_string (value, installation_get_keyboard (self));
		break;
		case INSTALLATION_AUTOLOGIN:
		g_value_set_boolean (value, installation_get_autologin (self));
		break;
		case INSTALLATION_STATE:
		g_value_set_int (value, installation_get_state (self));
		break;
		case INSTALLATION_PROGRESS:
		g_value_set_int (value, installation_get_progress (self));
		break;
		case INSTALLATION_DESCRIPTION:
		g_value_set_string (value, installation_get_description (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_installation_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Installation * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_INSTALLATION, Installation);
	switch (property_id) {
		case INSTALLATION_PARTITION:
		installation_set_partition (self, g_value_get_int (value));
		break;
		case INSTALLATION_DEVICE:
		installation_set_device (self, g_value_get_int (value));
		break;
		case INSTALLATION_USER_NAME:
		installation_set_user_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_PASSWORD:
		installation_set_password (self, g_value_get_string (value));
		break;
		case INSTALLATION_HOST_NAME:
		installation_set_host_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_FULL_NAME:
		installation_set_full_name (self, g_value_get_string (value));
		break;
		case INSTALLATION_GRUB_DEVICE:
		installation_set_grub_device (self, g_value_get_string (value));
		break;
		case INSTALLATION_LANGUAGE:
		installation_set_language (self, g_value_get_string (value));
		break;
		case INSTALLATION_REGION:
		installation_set_region (self, g_value_get_string (value));
		break;
		case INSTALLATION_KEYBOARD:
		installation_set_keyboard (self, g_value_get_string (value));
		break;
		case INSTALLATION_AUTOLOGIN:
		installation_set_autologin (self, g_value_get_boolean (value));
		break;
		case INSTALLATION_STATE:
		installation_set_state (self, g_value_get_int (value));
		break;
		case INSTALLATION_PROGRESS:
		installation_set_progress (self, g_value_get_int (value));
		break;
		case INSTALLATION_DESCRIPTION:
		installation_set_description (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch6_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally6;
	__catch6_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* installer_translate_uri (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "http://system", "file://" SYSTEM_PATH "/");
	uri = _tmp1_;
	result = uri;
	return result;
}


static gchar* installer_translate_install (Installer* self, const gchar* uri) {
	gchar* result = NULL;
	gchar* path = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = string_replace (_tmp0_, "http://install/", "");
	path = _tmp1_;
	_tmp2_ = path;
	_tmp3_ = g_str_has_prefix (_tmp2_, "show_log?");
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		uri = "file:///var/log/blankon-installer.log";
		_tmp4_ = uri;
		_tmp5_ = g_strdup (_tmp4_);
		result = _tmp5_;
		_g_free0 (path);
		return result;
	}
	_tmp6_ = g_strdup ("about:blank");
	result = _tmp6_;
	_g_free0 (path);
	return result;
}


static gchar* installer_translate_theme (Installer* self, const gchar* old) {
	gchar* result = NULL;
	gchar* uri = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	_tmp0_ = old;
	_tmp1_ = string_replace (_tmp0_, "theme://", "");
	_tmp2_ = _tmp1_;
	_tmp3_ = utils_get_icon_path (_tmp2_, 24);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strdup_printf ("file://%s", _tmp4_);
	_tmp6_ = _tmp5_;
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	uri = _tmp6_;
	result = uri;
	return result;
}


static WebKitWebView* _installer_getInspectorView_webkit_web_inspector_inspect_web_view (WebKitWebInspector* _sender, WebKitWebView* p0, gpointer self) {
	WebKitWebView* result;
	result = installer_getInspectorView ((Installer*) self, p0);
	return result;
}


static void __lambda5_ (Installer* self, WebKitWebFrame* frame, WebKitWebResource* resource, WebKitNetworkRequest* request, WebKitNetworkResponse* response) {
	WebKitWebResource* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (frame != NULL);
	g_return_if_fail (resource != NULL);
	g_return_if_fail (request != NULL);
	_tmp0_ = resource;
	_tmp1_ = webkit_web_resource_get_uri (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_str_has_prefix (_tmp2_, "theme://");
	if (_tmp3_) {
		WebKitNetworkRequest* _tmp4_ = NULL;
		WebKitWebResource* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp4_ = request;
		_tmp5_ = resource;
		_tmp6_ = webkit_web_resource_get_uri (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = installer_translate_theme (self, _tmp7_);
		_tmp9_ = _tmp8_;
		webkit_network_request_set_uri (_tmp4_, _tmp9_);
		_g_free0 (_tmp9_);
	} else {
		WebKitNetworkRequest* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp10_ = request;
		_tmp11_ = webkit_network_request_get_uri (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_str_has_prefix (_tmp12_, "http://install/");
		if (_tmp13_) {
			gchar* uri = NULL;
			WebKitWebResource* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			WebKitNetworkRequest* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			_tmp14_ = resource;
			_tmp15_ = webkit_web_resource_get_uri (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = installer_translate_install (self, _tmp16_);
			uri = _tmp17_;
			_tmp18_ = request;
			_tmp19_ = uri;
			webkit_network_request_set_uri (_tmp18_, _tmp19_);
			_g_free0 (uri);
		} else {
			gchar* uri = NULL;
			WebKitWebResource* _tmp20_ = NULL;
			const gchar* _tmp21_ = NULL;
			const gchar* _tmp22_ = NULL;
			gchar* _tmp23_ = NULL;
			WebKitNetworkRequest* _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			_tmp20_ = resource;
			_tmp21_ = webkit_web_resource_get_uri (_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp23_ = installer_translate_uri (self, _tmp22_);
			uri = _tmp23_;
			_tmp24_ = request;
			_tmp25_ = uri;
			webkit_network_request_set_uri (_tmp24_, _tmp25_);
			_g_free0 (uri);
		}
	}
}


static void ___lambda5__webkit_web_view_resource_request_starting (WebKitWebView* _sender, WebKitWebFrame* p0, WebKitWebResource* p1, WebKitNetworkRequest* p2, WebKitNetworkResponse* p3, gpointer self) {
	__lambda5_ ((Installer*) self, p0, p1, p2, p3);
}


static void __lambda6_ (Installer* self, WebKitWebFrame* frame, void* context) {
	void* _tmp0_ = NULL;
	void* _tmp1_ = NULL;
	void* _tmp2_ = NULL;
	g_return_if_fail (frame != NULL);
	_tmp0_ = context;
	utils_setup_js_class ((void*) _tmp0_);
	_tmp1_ = context;
	parted_setup_js_class ((void*) _tmp1_);
	_tmp2_ = context;
	installation_setup_js_class ((void*) _tmp2_);
}


static void ___lambda6__webkit_web_view_window_object_cleared (WebKitWebView* _sender, WebKitWebFrame* frame, void* context, void* window_object, gpointer self) {
	__lambda6_ ((Installer*) self, frame, context);
}


Installer* installer_construct (GType object_type) {
	Installer * self = NULL;
	WebKitWebSettings* settings = NULL;
	WebKitWebSettings* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	WebKitWebSettings* _tmp6_ = NULL;
	WebKitWebSettings* _tmp7_ = NULL;
	WebKitWebSettings* _tmp8_ = NULL;
	self = (Installer*) g_object_new (object_type, NULL);
	_tmp0_ = webkit_web_settings_new ();
	settings = _tmp0_;
	_tmp1_ = self->priv->debug;
	if (g_strcmp0 (_tmp1_, "1") == 0) {
		WebKitWebSettings* _tmp2_ = NULL;
		WebKitWebInspector* _tmp3_ = NULL;
		WebKitWebInspector* _tmp4_ = NULL;
		WebKitWebInspector* _tmp5_ = NULL;
		_tmp2_ = settings;
		g_object_set (_tmp2_, "enable-developer-extras", TRUE, NULL);
		g_object_get ((WebKitWebView*) self, "web-inspector", &_tmp3_, NULL);
		_tmp4_ = _tmp3_;
		_tmp5_ = _tmp4_;
		g_signal_connect_object (_tmp5_, "inspect-web-view", (GCallback) _installer_getInspectorView_webkit_web_inspector_inspect_web_view, self, 0);
		_g_object_unref0 (_tmp5_);
	}
	_tmp6_ = settings;
	g_object_set (_tmp6_, "enable-file-access-from-file-uris", TRUE, NULL);
	_tmp7_ = settings;
	g_object_set (_tmp7_, "enable-universal-access-from-file-uris", TRUE, NULL);
	_tmp8_ = settings;
	webkit_web_view_set_settings ((WebKitWebView*) self, _tmp8_);
	g_signal_connect_object ((WebKitWebView*) self, "resource-request-starting", (GCallback) ___lambda5__webkit_web_view_resource_request_starting, self, 0);
	g_signal_connect_object ((WebKitWebView*) self, "window-object-cleared", (GCallback) ___lambda6__webkit_web_view_window_object_cleared, self, 0);
	_g_object_unref0 (settings);
	return self;
}


Installer* installer_new (void) {
	return installer_construct (TYPE_INSTALLER);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		Installer* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->webview);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gboolean __lambda4_ (Block1Data* _data1_) {
	Installer* self;
	gboolean result = FALSE;
	WebKitWebInspector* _tmp0_ = NULL;
	WebKitWebInspector* _tmp1_ = NULL;
	WebKitWebInspector* _tmp2_ = NULL;
	self = _data1_->self;
	g_object_get (_data1_->webview, "web-inspector", &_tmp0_, NULL);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_;
	webkit_web_inspector_close (_tmp2_);
	_g_object_unref0 (_tmp2_);
	result = FALSE;
	return result;
}


static gboolean ___lambda4__gtk_widget_delete_event (GtkWidget* _sender, GdkEvent* event, gpointer self) {
	gboolean result;
	result = __lambda4_ (self);
	return result;
}


static WebKitWebView* installer_getInspectorView (Installer* self, WebKitWebView* inspectedView) {
	WebKitWebView* result = NULL;
	Block1Data* _data1_;
	GtkWindow* window = NULL;
	GtkWindow* _tmp0_ = NULL;
	WebKitWebView* _tmp1_ = NULL;
	GtkScrolledWindow* scrolled_window = NULL;
	GtkScrolledWindow* _tmp2_ = NULL;
	WebKitWebView* handle = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inspectedView != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp0_);
	window = _tmp0_;
	_tmp1_ = (WebKitWebView*) webkit_web_view_new ();
	g_object_ref_sink (_tmp1_);
	_data1_->webview = _tmp1_;
	_tmp2_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp2_);
	scrolled_window = _tmp2_;
	gtk_scrolled_window_set_policy (scrolled_window, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) _data1_->webview);
	gtk_container_add ((GtkContainer*) window, (GtkWidget*) scrolled_window);
	gtk_window_set_title (window, "Inspector");
	gtk_window_set_default_size (window, 640, 480);
	gtk_widget_show_all ((GtkWidget*) window);
	g_signal_connect_data ((GtkWidget*) window, "delete-event", (GCallback) ___lambda4__gtk_widget_delete_event, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	handle = _data1_->webview;
	result = handle;
	_g_object_unref0 (scrolled_window);
	_g_object_unref0 (window);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


void installer_start (Installer* self) {
	g_return_if_fail (self != NULL);
	webkit_web_view_load_uri ((WebKitWebView*) self, "http://system/index.html");
}


static void installer_class_init (InstallerClass * klass) {
	installer_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (InstallerPrivate));
	G_OBJECT_CLASS (klass)->finalize = installer_finalize;
}


static void installer_instance_init (Installer * self) {
	const gchar* _tmp0_ = NULL;
	self->priv = INSTALLER_GET_PRIVATE (self);
	_tmp0_ = g_getenv ("DEBUG");
	self->priv->debug = _tmp0_;
}


static void installer_finalize (GObject* obj) {
	Installer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INSTALLER, Installer);
	G_OBJECT_CLASS (installer_parent_class)->finalize (obj);
}


GType installer_get_type (void) {
	static volatile gsize installer_type_id__volatile = 0;
	if (g_once_init_enter (&installer_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (InstallerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) installer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Installer), 0, (GInstanceInitFunc) installer_instance_init, NULL };
		GType installer_type_id;
		installer_type_id = g_type_register_static (WEBKIT_TYPE_WEB_VIEW, "Installer", &g_define_type_info, 0);
		g_once_init_leave (&installer_type_id__volatile, installer_type_id);
	}
	return installer_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



